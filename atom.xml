<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Gosuke Miyashita]]></title>
    <link href="https://mizzy.org/atom.xml" rel="self"/>
    <link href="https://mizzy.org/"/>
    <updated>2026-02-01T09:20:53+09:00</updated>
    <id>https://mizzy.org/</id>
    <author>
        <name><![CDATA[Gosuke Miyashita]]></name>
    </author>
    <generator uri="https://github.com/mizzy/nebel/">Nebel</generator>

    <entry>
        <title type="html"><![CDATA[least - TerraformコードからIAMポリシーを自動生成するツール]]></title>
        <link href="https://mizzy.org/blog/2026/02/01/1/"/>
        <updated>2026-02-01T09:20:53+09:00</updated>
        <id>https://mizzy.org/blog/2026/02/01/1/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/least">least</a>というツールをつくった。Terraformのコードをみて、plan/applyに必要な権限を持つIAMポリシーを自動生成するツール。</p>
<hr />
<h2>きっかけ</h2>
<p>TerraformでGitHub Actions等から自動plan/applyを実行する際、plan/apply用ロールのIAMポリシーをどうするのが良いのか、いつも悩む。最小権限の原則は理想ではあるが、必要な権限を手動で調べてポリシーを作成するのは非常に面倒で、果たしてその苦労に見合うのか、と常々思っている。</p>
<p>最初に大きめの権限を与えておいて、IAM Access Analyzerを利用して後から権限を絞る、というアプローチもあるが、できれば最初から最小権限に近い状態で始めたい。</p>
<p>そんなことを考えていたところ、<a href="https://github.com/mizzy/carina">Carina</a>のawscc provider開発中に、<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/resource-type-schemas.html">CloudFormation resource provider schema</a>には各リソースタイプの作成・更新・削除に必要なIAMアクションが<code>handlers</code>という属性で定義されている、ということに気づいた。</p>
<p>例えば、S3バケット（<code>AWS::S3::Bucket</code>）のスキーマでは<code>handlers</code>は以下のように定義されている。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;create&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;permissions&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:CreateBucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:PutBucketTagging&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;...&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;read&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;permissions&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:GetAccelerateConfiguration&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:GetLifecycleConfiguration&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;...&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;update&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;permissions&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:PutBucketAcl&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:PutBucketTagging&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;...&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;delete&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;permissions&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:DeleteBucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:ListBucket&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;list&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;permissions&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;s3:ListAllMyBuckets&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>この情報を活用すればTerraformコードから必要なIAMポリシーを自動生成でき、労せず最小権限の原則を満たせるのでは、と思いついた。</p>
<p>思いついた時は<a href="https://2026.srekaigi.net/">SRE Kaigi 2026</a>に参加中でPCを持参していなかったので、<a href="https://code.claude.com/docs/ja/claude-code-on-the-web">Claude Code on the web</a>にスマホからアクセスし、こんなのつくって、とお願いしてつくってもらった。</p>
<p>ちなみにまだコードは見てないし、動作確認もしてない。</p>
<h2>機能</h2>
<p>機能的には、TerraformコードでIAMポリシーを生成する<code>generate</code>コマンドと、既存のIAMポリシーが持つ権限がTerraformコードに対して過不足がないかチェックする<code>check</code>コマンドを提供している。<code>check</code>コマンドは主にCIでの利用を想定している。</p>
<h2>今後</h2>
<p>まだ動作確認すらしてないので、とりあえず動作確認するところから。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carinaにデータソース機能を追加]]></title>
        <link href="https://mizzy.org/blog/2026/01/30/2/"/>
        <updated>2026-01-30T17:39:23+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/30/2/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>に<code>read</code>キーワードを追加し、既存のインフラリソースを参照できるようにした。Terraformのdata sourceに相当する機能。</p>
<h2>新しい構文</h2>
<p><code>read</code>キーワードを使って、既存のリソースを参照できる。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">aws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># 既存のVPCを読み取る（データソース）</span>
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">existing_vpc</span> <span class="o">=</span> <span class="k">read</span> <span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span> <span class="o">=</span> <span class="s2">&#34;production-vpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># 既存のVPC内に新しいサブネットを作成</span>
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">app_subnet</span> <span class="o">=</span> <span class="nc">aws.subnet</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>              <span class="o">=</span> <span class="s2">&#34;app-subnet&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">vpc_id</span>            <span class="o">=</span> <span class="nv">existing_vpc</span><span class="p">.</span><span class="nv">id</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span>        <span class="o">=</span> <span class="s2">&#34;10.0.100.0/24&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">availability_zone</span> <span class="o">=</span> <span class="nv">aws</span><span class="p">.</span><span class="err">A</span><span class="nv">vailability</span><span class="err">Z</span><span class="nv">one</span><span class="p">.</span><span class="nv">ap_northeast_1a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p><code>read</code>で定義したリソースは、ライフサイクルを管理しない。作成・更新・削除は行わず、現在の状態を読み取るだけ。</p>
<h2>プラン表示</h2>
<p><code>+</code>（作成）、<code>~</code>（更新）、<code>-</code>（削除）に加えて、<code>&lt;=</code>（読み取り）が表示される。(Ghostty上だと違う文字になってるけど)</p>
<p><img src="/images/2026-01-30-carina-data-source-plan.png" alt="プラン表示" /></p>
<h2>実装</h2>
<p>内部的には、<code>Resource</code>構造体に<code>read_only</code>フィールドを追加した。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Resource</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">id</span>: <span class="nc">ResourceId</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">attributes</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">read_only</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">  </span><span class="c1">// データソースの場合true
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre><p><code>Effect</code>列挙型の<code>Read</code>バリアントも変更し、リソース全体を保持するようにした。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Effect</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">resource</span>: <span class="nc">Resource</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// 変更前: Read(ResourceId)
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Create</span><span class="p">(</span><span class="n">Resource</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Update</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="nc">ResourceId</span><span class="p">,</span><span class="w"> </span><span class="n">from</span>: <span class="nc">State</span><span class="p">,</span><span class="w"> </span><span class="n">to</span>: <span class="nc">Resource</span><span class="w"> </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Delete</span><span class="p">(</span><span class="n">ResourceId</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre><p>パーサーは、<code>read</code>キーワードに続くリソース定義を解析し、<code>read_only = true</code>のリソースを生成する。プラン生成時、<code>read_only</code>なリソースは通常のdiff処理をスキップし、常に<code>Effect::Read</code>を生成する。</p>
<h2>関連リンク</h2>
<ul>
<li><a href="https://github.com/mizzy/carina/pull/35">Add read keyword for data sources by mizzy · Pull Request #35 · mizzy/carina</a></li>
</ul>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carinaで列挙型値の省略記法をサポート]]></title>
        <link href="https://mizzy.org/blog/2026/01/30/1/"/>
        <updated>2026-01-30T16:45:00+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/30/1/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>で、列挙型の値を省略して書けるようにした。</p>
<h2>以前の書き方</h2>
<p>これまでは、VPCのインスタンステナンシーを指定する場合、完全な名前空間付きの形式で書く必要があった。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="nc">awscc.vpc.vpc</span> <span class="nv">my_vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cidr_block</span>       <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">instance_tenancy</span> <span class="o">=</span> <span class="nc">awscc.vpc</span><span class="p">.</span><span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p><code>awscc.vpc.InstanceTenancy.dedicated</code>という記述は正確だが、冗長に感じられる。書くときは補完機能を使うので問題ないが、読みにくい。</p>
<h2>新しい書き方</h2>
<p>今回の変更で、3つの形式をサポートした。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="err">//</span> <span class="err">完全形式（従来通り）</span>
</span></span><span class="line"><span class="cl"><span class="na">instance_tenancy </span><span class="o">=</span> <span class="nc">awscc.vpc</span><span class="p">.</span><span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">//</span> <span class="err">型名</span> <span class="err">+</span> <span class="err">値</span>
</span></span><span class="line"><span class="cl"><span class="na">instance_tenancy </span><span class="o">=</span> <span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">//</span> <span class="err">値のみ</span>
</span></span><span class="line"><span class="cl"><span class="na">instance_tenancy </span><span class="o">=</span> <span class="nv">dedicated</span>
</span></span></code></pre><p>属性のスキーマには、どの名前空間に属するかの情報がある。<code>instance_tenancy</code>属性は<code>awscc.vpc</code>名前空間に属し、型名は<code>InstanceTenancy</code>だとわかっている。この情報を使って、省略形式を完全形式に展開する。</p>
<h2>実装</h2>
<p>パーサーは、未知の識別子を見つけると<code>UnresolvedIdent</code>として保持する。スキーマの検証時に、属性の名前空間情報を使って完全な形式に展開する。</p>
<p>LSPの補完も更新し、省略形式で候補を表示するようにした。<code>dedicated</code>や<code>default</code>といった短い形式で補完される。</p>
<h2>関連リンク</h2>
<ul>
<li><a href="https://github.com/mizzy/carina/pull/34">Add shorthand enum value support with schema-based namespace resolution by mizzy · Pull Request #34 · mizzy/carina</a></li>
</ul>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carina aws providerとawscc provider]]></title>
        <link href="https://mizzy.org/blog/2026/01/29/2/"/>
        <updated>2026-01-29T22:07:30+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/29/2/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>に、aws providerに加えてawscc providerを実装してみた。</p>
<hr />
<h2>背景</h2>
<p>以前、<a href="https://mizzy.org/blog/2026/01/24/2/">AWS Cloud Control APIは遅い？</a>という記事で、Cloud Control APIは遅いので採用をやめた、と書いた。しかし、その後考えが変わった。</p>
<p>Cloud Control APIには以下のメリットがある。</p>
<ul>
<li>CloudFormationと同じリソースモデルを使っているため、リソースのスキーマが公式に定義されている</li>
<li>新しいリソースタイプやプロパティが追加された場合、CloudFormationのスキーマが更新されれば自動的にサポートできる</li>
<li>統一されたAPIで様々なリソースを操作できる</li>
</ul>
<p>確かに遅いが、遅さが許容できるユースケースもあるはずだし、もっと多くのリソースを扱ってみると、実はCloud Control APIの方が便利、という場面も出てくるかもしれない。</p>
<p>また、両方のプロバイダを用意しておけば、ユーザーがユースケースに応じて選択できる。</p>
<p>というわけで、aws provider（直接SDKを使う高速な方式）とawscc provider（Cloud Control APIを使う方式）の両方を実装しはじめた。</p>
<hr />
<h2>DSL構文</h2>
<h3>awsプロバイダ</h3>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">aws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>                 <span class="o">=</span> <span class="s2">&#34;example-vpc&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span>           <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_support</span>   <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_hostnames</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">instance_tenancy</span>     <span class="o">=</span> <span class="nc">aws.vpc</span><span class="p">.</span><span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><h3>awsccプロバイダ</h3>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">awscc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">awscc.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>                 <span class="o">=</span> <span class="s2">&#34;cloudcontrol-vpc&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span>           <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_support</span>   <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_hostnames</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">instance_tenancy</span>     <span class="o">=</span> <span class="nc">awscc.vpc</span><span class="p">.</span><span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>基本的な構文は同じだが、以下の点が異なる。</p>
<ul>
<li>プロバイダ名が<code>aws</code>と<code>awscc</code></li>
<li>リソースタイプが<code>aws.vpc</code>と<code>awscc.vpc</code></li>
<li>enum値の名前空間が<code>aws.vpc.InstanceTenancy</code>と<code>awscc.vpc.InstanceTenancy</code></li>
</ul>
<p><code>aws</code>と<code>awscc</code>を置換するだけで切り替えられるようになっている。今後追加するリソースタイプも、基本的には両方とも同じスキーマで定義できるようにして、簡単に切り替えられるようにする予定。そうすることで、どちらがどういうユースケースに適しているかを試しやすくなるはず。</p>
<p>Terraformのaws providerは、SDKのAPI構造をなぞる形でリソースやプロパティが定義されている。例えば、aws provider v4で、<code>aws_s3_bucket</code>リソースから<code>acl</code>, <code>website</code>, <code>cors_rule</code>, <code>versioning</code>などが分離され、それぞれ独立したリソースタイプになった。おそらく開発効率や保守性を高めるための変更だと思うが、ユーザーからするとリソースが増えて複雑になる。</p>
<p>一方、Cloud Control APIはCloudFormationのスキーマをベースにしているため、リソースタイプやプロパティが一貫している。例えば、S3バケットのACLやウェブサイト設定、CORS設定、バージョニング設定などは、すべて<code>AWS::S3::Bucket</code>リソースのプロパティとして定義されている。これにより、リソースモデルがシンプルで理解しやすくなる。</p>
<p>Carinaのaws providerとawscc providerは、Cloud Control APIのスキーマをベースにしている。これにより、両方のプロバイダで同じリソースタイプやプロパティを提供できる。ユーザーは、ユースケースに応じてどちらのプロバイダを使うか選択しやすくなるし、切り替えも簡単になる。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Nebelにシンタックスハイライト機能を追加した]]></title>
        <link href="https://mizzy.org/blog/2026/01/29/1/"/>
        <updated>2026-01-29T18:55:03+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/29/1/</id>
        <content type="html"><![CDATA[
<p>最近このブログは、<a href="https://github.com/mizzy/carina">Carina</a>の開発進捗報告の場と化して更新頻度が上がっているので、ブログ自体にも手を入れていっている。</p>
<p>2日前には<a href="https://mizzy.org/blog/2026/01/27/2/">OGP画像自動生成機能を追加した</a>が、今回はコードのシンタックスハイライト機能を追加した。</p>
<hr />
<h2>実装内容</h2>
<p>Markdownパーサとして使っている<a href="https://github.com/yuin/goldmark">goldmark</a>に、<a href="https://github.com/yuin/goldmark-highlighting">goldmark-highlighting</a>拡張を追加した。バックエンドには<a href="https://github.com/alecthomas/chroma">Chroma</a>というGo製のシンタックスハイライターを使っている。</p>
<p>テーマは<a href="https://catppuccin.com/">Catppuccin Mocha</a>を採用した。パステル調のダークテーマで、紫・青・緑・オレンジ・ピンクの柔らかい配色が特徴。ブログの背景が白なので、ダークテーマの方がコードブロックが目立つかな、と思って選んだ。</p>
<hr />
<h2>使い方</h2>
<p>Markdownで言語を指定してコードブロックを書くと、自動的にハイライトされる。</p>
<p>たとえばJSONを書くとこうなる。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;example&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>Bashだとこう。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="s2">&#34;Hello, World!&#34;</span>
</span></span></code></pre><hr />
<h2>Carina言語のサポート</h2>
<p>せっかくなので、開発中の<a href="https://github.com/mizzy/carina">Carina</a>用のカスタムレクサーも追加した。Chromaはカスタムレクサーを定義できるので、独自言語のハイライトも可能。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">backend</span> <span class="nv">s3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">bucket</span>      <span class="o">=</span> <span class="s2">&#34;my-carina-state&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">key</span>         <span class="o">=</span> <span class="s2">&#34;prod/carina.crnstate&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">encrypt</span>     <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">auto_create</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">main_vpc</span> <span class="o">=</span> <span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>       <span class="o">=</span> <span class="s2">&#34;main-vpc&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span> <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>キーワード、文字列、真偽値、リソースタイプなどが適切にハイライトされる。</p>
<hr />
<h2>CSSの統一</h2>
<p>言語指定ありのコードブロックはChromaでハイライトされるが、言語指定なしのコードブロックは素の<code>&lt;pre&gt;</code>タグで出力される。見た目を統一するため、<code>base.css</code>の<code>pre</code>スタイルもCatppuccin Mochaテーマに合わせた。</p>
<p>また、コードブロックのフォントサイズを本文と同じ16pxにして、読みやすさを向上させた。</p>
<pre><code>言語指定なしのコードブロックも
同じダークブルー背景で表示される
</code></pre>
<hr />
<h2>まとめ</h2>
<ul>
<li>goldmark-highlighting（Chroma）でシンタックスハイライトを実装</li>
<li>Catppuccin Mochaテーマでパステル調のダークなコードブロックに</li>
<li>Carina言語用のカスタムレクサーを追加</li>
<li>フォントサイズを本文と統一して読みやすく</li>
<li>言語指定なしのコードブロックもスタイルを統一</li>
</ul>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carina State Management]]></title>
        <link href="https://mizzy.org/blog/2026/01/28/1/"/>
        <updated>2026-01-28T21:40:00+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/28/1/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>にS3バックエンドによるState管理機能を実装した。</p>
<hr />
<h2>背景</h2>
<p>Terraform Stateと同等の機能はやっぱり必要だよね、ということで、CarinaにもState管理機能とS3バックエンドを実装した。</p>
<hr />
<h2>DSL構文</h2>
<p>バックエンド設定は以下のように記述する。ほぼTerraformと同じ。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">backend</span> <span class="nv">s3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">bucket</span>      <span class="o">=</span> <span class="s2">&#34;my-carina-state&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">key</span>         <span class="o">=</span> <span class="s2">&#34;prod/carina.crnstate&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">encrypt</span>     <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">auto_create</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p><code>auto_create = true</code>はTerraformにはない機能。Terraformでは、Stateを保存するS3バケットは事前に作成しておく必要がある。Carinaでは<code>auto_create</code>を有効にすると、初回<code>apply</code>時にバケットが自動作成され、さらにそのバケットのリソース定義が<code>.crn</code>ファイルに自動で追加される。</p>
<hr />
<h2>Stateファイル</h2>
<p>StateファイルはJSON形式で、以下のような構造になっている。とりあえずClaude Codeに適当に決めてもらった。後で色々変えることになると思う。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;serial&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;lineage&#34;</span><span class="p">:</span> <span class="s2">&#34;358893ec-5a07-49bf-acbc-940d9563c7f5&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;carina_version&#34;</span><span class="p">:</span> <span class="s2">&#34;0.1.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;resources&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;resource_type&#34;</span><span class="p">:</span> <span class="s2">&#34;s3.bucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;my-bucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;provider&#34;</span><span class="p">:</span> <span class="s2">&#34;aws&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;attributes&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;my-bucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;region&#34;</span><span class="p">:</span> <span class="s2">&#34;ap-northeast-1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;versioning&#34;</span><span class="p">:</span> <span class="s2">&#34;Enabled&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;protected&#34;</span><span class="p">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><ul>
<li><code>serial</code>: 変更のたびにインクリメントされる</li>
<li><code>lineage</code>: 状態ファイルの系譜を識別するUUID（誤上書き防止）</li>
<li><code>protected</code>: trueの場合、<code>destroy</code>で削除されない</li>
</ul>
<hr />
<h2>plan</h2>
<p><code>plan</code>実行時に、Stateバケットが作成されることが<code>Bootsrap Plan:</code>として表示される。</p>
<p><img src="/images/2026/01/carina-state-bootstrap.png" alt="carina plan の出力" /></p>
<hr />
<h2>apply</h2>
<p>apply実行時に、Stateバケットが自動作成される。</p>
<p><img src="/images/2026/01/carina-state-apply.png" alt="carina apply の出力" /></p>
<p>また、backendが定義されているファイルに、Stateバケットのリソース定義が自動追加される。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="c"># Auto-generated by carina (state bucket)</span>
</span></span><span class="line"><span class="cl"><span class="nc">aws.s3.bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>       <span class="o">=</span> <span class="s2">&#34;my-carina-state&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">versioning</span> <span class="o">=</span> <span class="s2">&#34;Enabled&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><hr />
<h2>destroy</h2>
<p>StateバケットはState内で<code>protected</code>フラグが設定されるため、通常の<code>destroy</code>では削除されない。</p>
<p><img src="/images/2026/01/carina-state-destroy.png" alt="carina destroy の出力" /></p>
<p>「⚠ s3.bucket.carina-state-test-mizzy (protected - will be skipped)」と表示され、destroy対象からスキップされる。</p>
<p>Stateバケットを削除したい場合は、<code>state bucket-delete</code>コマンドを使う。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ carina state bucket-delete &lt;bucket-name&gt; --force
</span></span></code></pre><hr />
<h2>state lock/unlock</h2>
<p>チーム開発にはstate lock/unlockは必要だよね、ってことでTerraformのようなstate lock/unlock機能も実装した。</p>
<hr />
<h2>今後</h2>
<p>Terraform Stateに関する不満として一番大きいのは、やはりstate refreshの速度だと思う。<a href="https://mizzy.org/blog/2022/03/24/1/">Terraform State Refreshの高速化手法と実装</a> という記事で、高速化するための手法や実装をいくつか挙げたが、あくまでもTerraformを前提としたものだった。Carinaではその前提が取っ払えるので、もっとよい形での高速化が実現できるかもしれないし、できないかもしれない。今後の課題として取り組んでいきたい。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[NebelにOGP画像自動生成機能を追加した]]></title>
        <link href="https://mizzy.org/blog/2026/01/27/2/"/>
        <updated>2026-01-27T19:08:09+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/27/2/</id>
        <content type="html"><![CDATA[
<p>tokuhiromさんの<a href="https://blog.64p.org/entry/2026/01/26/110749">ogp を設定した</a>という記事を読んで、そういえば自分もOGP対応しなきゃな、と思い出した。以前から対応しようと思いつつ、画像生成とか面倒だな、と後回しにしていた。でも今なら生成AIでシュッと対応できるな、と思ってやってみた。</p>
<p>ちなみにこのブログ記事もClaude Codeが書いたものをそのまま出している。</p>
<p>このブログの静的サイトジェネレータである<a href="https://github.com/mizzy/nebel">Nebel</a>に、OGP画像を自動生成する機能を追加した。</p>
<hr />
<h2>OGP画像とは</h2>
<p>OGP（Open Graph Protocol）画像は、SNSでURLをシェアしたときに表示されるサムネイル画像のこと。TwitterやFacebookなどでリンクを共有すると、タイトルや説明文と一緒に画像が表示される。</p>
<p>これまでこのブログにはOGP画像を設定していなかったので、SNSでシェアしてもデフォルトの味気ない表示になっていた。</p>
<hr />
<h2>実装内容</h2>
<p><code>nebel generate</code>を実行すると、各記事のタイトルからOGP画像（1200x630px）を自動生成するようにした。</p>
<ul>
<li><strong>サイズ</strong>: 1200x630px（OGP推奨サイズ）</li>
<li><strong>背景</strong>: ダークグレー（#333）</li>
<li><strong>テキスト</strong>: 記事タイトル（白色、中央配置）</li>
<li><strong>フォント</strong>: Noto Sans CJK JP Bold（日本語対応）</li>
</ul>
<p>生成される画像はこんな感じ。</p>
<p><img src="/blog/2026/01/27/2/ogp.png" alt="OGP画像のサンプル" /></p>
<hr />
<h2>使用ライブラリ</h2>
<p>Goで画像を生成するために<a href="https://github.com/fogleman/gg">fogleman/gg</a>というライブラリを使った。シンプルなAPIで2D描画ができるので、こういった用途にはちょうど良い。</p>
<p>日本語フォントには<a href="https://fonts.google.com/noto/specimen/Noto+Sans+JP">Noto Sans CJK JP</a>を使用。CJK（中国語・日本語・韓国語）に対応しているので、日本語タイトルも問題なく描画できる。</p>
<hr />
<h2>テンプレートの変更</h2>
<p>HTMLテンプレートには、OGPとTwitter Cardのメタタグを追加した。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="c">&lt;!-- OGP --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:title&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;{{ .Title }}&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;article&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:url&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;https://mizzy.org{{ .Path }}/&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:image&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;https://mizzy.org{{ .OGImagePath }}&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:site_name&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;Gosuke Miyashita&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- Twitter Card --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;twitter:card&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;summary_large_image&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;twitter:title&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;{{ .Title }}&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;twitter:image&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;https://mizzy.org{{ .OGImagePath }}&#34;</span><span class="p">/&gt;</span>
</span></span></code></pre><p>これで、SNSでシェアしたときにタイトル入りの画像が表示されるようになる。</p>
<hr />
<h2>今後</h2>
<p>デザインは現状かなりシンプルなので、余裕があればもう少し凝ったものにしたい。ロゴを入れたり、グラデーション背景にしたり、といったあたりは比較的簡単にできそう。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carinaの型システムについて]]></title>
        <link href="https://mizzy.org/blog/2026/01/27/1/"/>
        <updated>2026-01-27T09:54:37+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/27/1/</id>
        <content type="html"><![CDATA[
<p>Terraformライクなツール<a href="https://github.com/mizzy/carina">Carina</a>をつくりはじめた動機のひとつに、「型システムの強化」がある。</p>
<p>Terraformではプリミティブな型（string, number, bool）に加えて、listやmap、objectなどの複合型がサポートされている。しかし、型システム自体はあまり強力ではない。</p>
<p>例えば、regionやcidr_blockのような特定のドメインに特化した型は存在しない。そのため、これらの値を扱う際には単なるstring型として扱われ、誤った値が設定される可能性がある。誤った設定をした場合、validateやplanで気づけるのであればまだ良いが、planが通ってしまい、apply時にエラーになってはじめて間違いが発覚することもある。</p>
<p>これを防ぐために、Carinaではドメイン固有型の導入を試している。現在実装しているものとして、region型やcidr型がある。これらの型は、それぞれのドメインに特化したバリデーションロジックを持っており、不正な値が設定された場合には即座にエラーを返す。</p>
<p>例えば、誤ってリージョンを指定すべきところにアベイラビリティゾーンを指定したとする。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="k">aws</span> {
</span></span><span class="line"><span class="cl"><span class="n">  region</span> <span class="o">=</span> <span class="s2">&#34;ap-northeast-1a&#34;</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre><p>Terraformではさすがに<code>plan</code>は通らないが、<code>validate</code>は通る。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ terraform validate
</span></span><span class="line"><span class="cl">Success! The configuration is valid.
</span></span></code></pre><p>Carinaもproviderの定義はTerraformと同じように記述するが、<code>validate</code>で以下のようなエラーが返る。</p>
<pre class="chroma"><code><span class="line"><span class="cl">Error: provider aws: Validation failed: Invalid region <span class="s1">&#39;ap-northeast-1a&#39;</span>, expected one of: ap-northeast-1, ap-northeast-2, ap-northeast-3, ap-southeast-1, ap-southeast-2, ap-south-1, us-east-1, us-east-2, us-west-1, us-west-2, eu-west-1, eu-west-2, eu-west-3, eu-central-1, eu-north-1, ca-central-1, sa-east-1 or DSL format like aws.Region.ap_northeast_1
</span></span></code></pre><p>このようにCarinaでは、型システムを強化することで、より早い段階で設定ミスを検出できるようにしたい、と考えている。</p>
<p>また、CarinaではAWSリージョンはEnum型として定義されているため、以下のようにリージョンを指定することもできる。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">aws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>更にLSPもサポートしているため、IDE上で補完候補としてリージョンの一覧が表示される。</p>
<p><img src="/images/2026/01/carina-region-completion.png" alt="リージョンの補完候補" /></p>
<p>誤った文字列を指定している場合も、IDE上でエラーが表示される。</p>
<p><img src="/images/2026/01/carina-region-error.png" alt="IDEでのエラー表示" /></p>
<p>もう一つの例として、cidr型を紹介する。cidr型はCIDR表記のIPアドレスブロックを表す型で、不正なCIDR表記が指定された場合にはエラーを返す。</p>
<p>例えば、以下のように不正なプレフィックス長を指定したとする。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">main_vpc</span> <span class="o">=</span> <span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">name</span>       <span class="o">=</span> <span class="s2">&#34;main-vpc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cidr_block</span> <span class="o">=</span> <span class="s2">&#34;10.0.0.0/33&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p><code>carina validate</code>を実行すると、以下のようなエラーが返る。</p>
<pre><code>Error: vpc.main-vpc: Validation failed: Invalid prefix length '33': must be 0-32
</code></pre>
<p>Terraformでもvalidateで同様のエラーが返るが、IntelliJ IDEAのTerraformプラグインではCIDR表記のフォーマットエラーが検出されない。CarinaのLSPでは、IDE上で以下のようにエラーが表示される。</p>
<p><img src="/images/2026/01/carina-cidr-error.png" alt="cidr_blockのエラー表示" /></p>
<p>まったくCIDR表記として成り立っていない場合も、当然ながらIDE上でエラーが表示される。</p>
<p><img src="/images/2026/01/carina-cidr-format-error.png" alt="cidr_blockのフォーマットエラー表示" /></p>
<p>cidr型でもregion型と同様に、補完候補として一般的なCIDR表記が表示される。</p>
<p><img src="/images/2026/01/carina-cidr-completion.png" alt="cidr_blockの補完候補" /></p>
<p>さらに別の例として、S3バケットの<code>versioning_configuration</code>属性を紹介する。<code>versioning_configuration</code>はS3バケットのバージョニング設定を表すオブジェクト型で、<code>status</code>フィールドには<code>Enabled</code>または<code>Suspended</code>のいずれかを文字列で指定する必要がある（<code>Disabled</code>もあるがこれはちょっと特殊な値）。誤った文字列を指定すると、validateやplanでは不正な値が検出されるが、IDE上ではエラーや補完候補が表示されないため、あれ、Enableだっけ？Enabledだっけ？と迷ったら公式ドキュメントを確認する必要がある。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">resource</span> <span class="s2">&#34;aws_s3_bucket_versioning&#34; &#34;versioning_example&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  bucket</span> <span class="o">=</span> <span class="k">aws_s3_bucket</span><span class="p">.</span><span class="k">example</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">  <span class="k">versioning_configuration</span> {
</span></span><span class="line"><span class="cl"><span class="n">    status</span> <span class="o">=</span> <span class="s2">&#34;Enabled&#34;</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre><p>Carinaでは、このstatusフィールドをEnum型として定義しているため、以下のように補完候補として&quot;Enabled&quot;と&quot;Suspended&quot;が表示される。</p>
<p><img src="/images/2026/01/carina-s3-versioning-completion.png" alt="S3バケットのversioning補完" /></p>
<p>エディタ上でのエラー表示や自動補完については、今は生成AIが基本的にコードを書いてくれるのであまり気にする必要はないかもしれない。しかし、型システムが強力であればあるほど、生成AIがより正確なコードを生成できるようになり、早い段階で間違いに気づけるようになるはず。</p>
<p>型システムを強化するためには、各リソースの属性やその型情報を正確に把握する必要がある。AWSの場合、CloudFormationのリソースタイプスキーマを利用することで、各リソースの属性情報を取得できる。例えば、以下のコマンドを実行すると、S3バケットリソースのスキーマ情報が取得できる。</p>
<pre class="chroma"><code><span class="line"><span class="cl">aws cloudformation describe-type <span class="se">\
</span></span></span><span class="line"><span class="cl">      --type RESOURCE <span class="se">\
</span></span></span><span class="line"><span class="cl">      --type-name AWS::S3::Bucket <span class="se">\
</span></span></span><span class="line"><span class="cl">      --query <span class="s2">&#34;Schema&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">      --output text
</span></span></code></pre><p>これを元にCarinaで型定義を自動生成するなり、AIに生成させるなりすれば、型システムの強化がより容易になると考えている。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[carina planで依存関係を可視化]]></title>
        <link href="https://mizzy.org/blog/2026/01/25/2/"/>
        <updated>2026-01-25T15:14:36+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/25/2/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>の<code>plan</code>コマンドで、リソース間の依存関係をツリー構造で表示できるようにした。</p>
<p><img src="/images/2026/01/carina-plan.png" alt="carina plan の出力" /></p>
<p>Terraformの<code>plan</code>コマンドは、作成・変更・削除されるリソースがフラットなリストで表示される。どのリソースが作成されるかはわかるが、リソース間の依存関係は出力からは読み取れない。</p>
<p>Carinaの<code>plan</code>では、依存関係に基づいてリソースがツリー構造で表示される。上の例だと、VPCの下にSecurity Groupがあり、その下にIngress Ruleがある、という階層構造が一目でわかる。</p>
<p>これにより、planの出力を見るだけで、リソース間の依存関係を把握できる。</p>

]]></content>
    </entry>

</feed>
