<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Gosuke Miyashita]]></title>
    <link href="https://mizzy.org/atom.xml" rel="self"/>
    <link href="https://mizzy.org/"/>
    <updated>2025-02-24T21:05:24+09:00</updated>
    <id>https://mizzy.org/</id>
    <author>
        <name><![CDATA[Gosuke Miyashita]]></name>
    </author>
    <generator uri="https://github.com/mizzy/nebel/">Nebel</generator>

    <entry>
        <title type="html"><![CDATA[長時間のパソコン作業に適したホテル一選]]></title>
        <link href="https://mizzy.org/blog/2025/02/24/1/"/>
        <updated>2025-02-24T21:05:24+09:00</updated>
        <id>https://mizzy.org/blog/2025/02/24/1/</id>
        <content type="html"><![CDATA[
<p>三選とか十選とかいきたいところだけど、自分の少ないホテル宿泊経験では、ヒルトン福岡シーホークぐらいしか知らないので。</p>
<p>出張の際にホテルの部屋でパソコン仕事する際、問題になるのが椅子。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">家で仕事してると、椅子のことはあまり意識しないんだけど、ホテルで仕事してるとすぐに腰や背中が痛くなってくるので、家で使ってる椅子は本当に疲れにくいんだな、ということを実感する。</p>&mdash; mizzy (@gosukenator) <a href="https://twitter.com/gosukenator/status/1605182622703161346?ref_src=twsrc%5Etfw">December 20, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>その点、ヒルトン福岡シーホークは<a href="https://jp.steelcase.com/collections/chairs-seating/products/think">SteelcaseのThinkチェア</a>が配備されていて、長時間パソコン作業しても疲れにくい。</p>
<p>ホテルサイトの写真を見る限りでは、和室以外のほとんどの部屋に配備されてそう。</p>
<blockquote>
<p><a href="https://www.hilton.com/ja/hotels/fukhihi-hilton-fukuoka-sea-hawk/rooms/">https://www.hilton.com/ja/hotels/fukhihi-hilton-fukuoka-sea-hawk/rooms/</a><br />
<img src="/images/2025/02/seahawk-rooms.png" alt="" /></p>
</blockquote>
<p>実際、<a href="https://mizzy.hateblo.jp/entry/2024/05/07/115701">色々なタイプの部屋に宿泊</a>したけど、スイート和洋室以外はすべてThinkチェアだった。欲を言えば、アームレストの高さが調節できるタイプだとなお良いのだけど、まともなワークチェアがあるだけで十分ありがたい。</p>
<p>ヒルトン福岡シーホーク以外だと、羽田エクセルホテル東急のプレミアと呼ばれるタイプの部屋にはThinkチェアがある模様。</p>
<blockquote>
<p><a href="https://www.tokyuhotels.co.jp/haneda-e/room/index.html">https://www.tokyuhotels.co.jp/haneda-e/room/index.html</a><br />
<img src="/images/2025/02/haneda-excel-hotel-rooms.png" alt="" /></p>
</blockquote>
<p>自分はスタンダードタイプの部屋には泊まったことがあるけど、Thinkチェアはなかった。</p>
<p>ホテル検索サイト、椅子でも検索できるといいのに。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[DuckDBで課金時間の多いGitHub Actionsワークフローを抽出]]></title>
        <link href="https://mizzy.org/blog/2025/02/15/1/"/>
        <updated>2025-02-15T09:03:26+09:00</updated>
        <id>https://mizzy.org/blog/2025/02/15/1/</id>
        <content type="html"><![CDATA[
<script src="https://gist.github.com/mizzy/774585268e81b49f38173f8e88622521.js"></script>
<p>ChatGPTにやらせても良い。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[吉祥寺.pm37に参加した]]></title>
        <link href="https://mizzy.org/blog/2025/02/01/1/"/>
        <updated>2025-02-01T01:38:10+09:00</updated>
        <id>https://mizzy.org/blog/2025/02/01/1/</id>
        <content type="html"><![CDATA[
<p><a href="https://kichijojipm.connpass.com/event/339040/">【n回目の増枠！！】吉祥寺.pm37【おいでよ吉祥寺！オフライン開催！】 - connpass</a></p>
<p>吉祥寺.pm初参加。コロナ禍以後、オフラインの技術系イベントは、CloudNative Days Fukuoka 2023とPHPカンファレンス福岡2024ぐらいしか参加していなかったので、もっと積極的に参加するようにしよう、と思ったタイミングで開催が目に止まったので参加してきた。</p>
<p>この記事は、参加レポートというほどでもない、雑なメモです。</p>
<hr />
<h2>会場到着まで</h2>
<p>開始時刻が19時で、それぐらいに到着するよう電車に乗ると、退勤ラッシュに巻き込まれそうだな、と思ったので早めに移動。17時には吉祥寺駅に着いていた。まだ使い切っていないモスカードがあるので、モスバーガーに入って<a href="https://www.oreilly.co.jp/books/9784814400911/">Tidy First?</a>でも読みながら時間まで待とう、と思ったが、改装中で休業だった。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">永久不滅ポイントと交換したモスカード2000円分x 5枚が届いた。残高移行して一枚にまとめた。これでモスバーガーで豪遊する。 <a href="https://t.co/o9FkTorEuc">pic.twitter.com/o9FkTorEuc</a></p>&mdash; mizzy (@gosukenator) <a href="https://twitter.com/gosukenator/status/1801092740383686798?ref_src=twsrc%5Etfw">June 13, 2024</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>当てが外れて、どこで時間潰そうかとウロウロしたのだけど、めんどくさくなって結局南口のマクドナルドにした。期間限定のメキシカンチーズチキン、もう1回ぐらい食べとくか、と思ったら販売してなかったので、チーズダブルてりやきを食べた。</p>
<p>で、Tidy First?読みながら時間潰していたのだけど、そういえばconnpassには開始時刻は書いてたけど、開場時刻は書いてなかったよな、何時になったら入れるんだろう、と思い、つぶやいておけば誰か反応してくれるかも、と思ったらsongmuさんが教えてくださった。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">18:30のようです <a href="https://t.co/1Uj9P3rb3P">https://t.co/1Uj9P3rb3P</a></p>&mdash; songmu (@songmu) <a href="https://twitter.com/songmu/status/1885257591884038484?ref_src=twsrc%5Etfw">January 31, 2025</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>ありがとうございました、助かりました。</p>
<hr />
<h2>会場到着</h2>
<p>受付があったけど、懇親会に参加しない自分は特に何もする必要がなかった。<a href="https://x.com/magnolia_k_">@magnolia_k_</a>さんにPayPayでカンパするためのQRコードがあったのでカンパした。企業スポンサーとかついてないのに参加費無料なので、会場代は@magnolia_k_さんのポケットマネーから出してるのかな、と思ってご本人に聞いたら、やはりそうだとのこと。ただ、毎回カンパで、赤字にもならず、それほど多過ぎもしない額が集まってるとのことなので安心した。</p>
<p>老眼が進んできてるので前から2列目の席に座った。</p>
<hr />
<h2>発表について</h2>
<p>LT含めて全部で発表者が15人と多いので、全てには触れずに、特に強く印象に残ったものだけ。</p>
<h3>初めての海外カンファレンス</h3>
<p>masasuzuさんによる発表。</p>
<p>今回のテーマは「ぼくのかんがえたさいきょうのアーキテクチャ」なのだけど、connpassでこの文章読み飛ばしていて、会場で聞いて初めて知った。そして、発表者のmasasuzuさんもテーマをご存知なかったとのことで、全然関係ないテーマですみません、と謝罪していて、ああ、知らなかったの自分だけじゃなく、発表者の方もなんだ、と妙に面白かった。</p>
<h3>ポッドキャストは作れる!</h3>
<p>Songmuさんの発表。Indie Web、コンテンツを自分で管理して公開したい、ブログエンジンも自作OSS、funが大事、といった話に共感しかなくて、これに関して自分の思うところを書こうと思ったら、ここだけ長文になって記事全体のバランスが悪くなるので、たぶん別記事で書くかもしれないし書かないかもしれない。</p>
<h3>DSLによる抽象レイヤーの構築</h3>
<p>yonekuboさんの発表。最初の方は、内部DSLや外部DSLとは、といったおさらい的な話。おすすめのDSLに関する本が2冊とも絶版になってる、と聞いて、確かに、最近はDSLって言葉を敢えて使うことはなく、当たり前のようにDSLを使っているよな、と。今更感のあるDSLの話をどう展開するのかな、と思ったら、後半は生成AIやJSXを絡めた今風なDSLの使い方の話になっていき、とても楽しめた。</p>
<h3>もうひとつのアーキテクチャ</h3>
<p>kondoyukoさんの発表。kondoyukoさん、以前から存じ上げていたけど、発表ははじめて聞いた。本物のアーキテクチャの話（建築の話）だった。</p>
<h3>AWSを使ったイベントの配信アーキテクチャ</h3>
<p>r_takaishiさんの発表。出てくるAWSのサービスが、全部聞いたことないやつだった。</p>
<h3>waiwai-aiを入社2ヶ月のエンジニア3人と作るためのさいきょうのアーキテクチャ</h3>
<p>Furudonoさんの発表。まさにコンウェイの法則の具体例で、4人チームと少人数でもこの法則が適用されるのか、面白い、と思った。</p>
<h3>戸籍の話 (connpass上ではTBDになってて正確なタイトル忘れた)</h3>
<p>toya524287さんの発表。<a href="https://toya.hatenablog.com/entry/2024/06/01/180018">先祖の戸籍の写しを取り寄せてみたら、214年前（江戸時代、文化7年）までさかのぼれた - Really Saying Something</a>の内容を5分で、といった感じの内容。ちゃんとアーキテクチャにも絡めた話にまとまっていてよかった。</p>
<p>以前勤めていた会社で、自由なテーマで発表するLT回をやったことがあるのだけど、その時のことを思い出した。自分はその時、<a href="https://www.slideshare.net/slideshow/ia-14907107/14907107">Ia型超新星とチャンドラセカール限界</a>というタイトルで発表した。</p>
<hr />
<h2>その他</h2>
<p>会場に早めに着いて、magnoliaさんとお話しできたのは良かったけど、それ以外の方とは全然お話しできなかった。参加者一覧を見ると、知り合いが結構参加してそうだったけど、全然見つけられなかった、というかそもそも、見つけて話かけるような時間がなかった。</p>
<p>帰りの電車の時間があるので懇親会に参加しないですぐに帰ったのだけど、今度は車で行って懇親会に参加しようかな、と思った。お酒飲めないのは損に感じることが多いのだけど、こういう場合に車移動を躊躇なく選択できるメリットもある。</p>
<p>最後に一句詠む発表者が多くてなぜだろう、と思ったら途中で解説があって、武蔵野公会堂の利用申請で、利用目的で「趣味」カテゴリを選ぶと「句会」しか選択肢がないとのことで、句会で利用申請しているから、とのことだった。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Git scrapingでヒルトンの宿泊料金/ポイントをウォッチ]]></title>
        <link href="https://mizzy.org/blog/2025/01/30/1/"/>
        <updated>2025-01-30T13:25:16+09:00</updated>
        <id>https://mizzy.org/blog/2025/01/30/1/</id>
        <content type="html"><![CDATA[
<p>自分はHilton Honors会員かつ<a href="https://www.hpcj.jp/">HPCJ</a>会員なので、ポイントを利用する場合やHPCJ対象外ホテルを予約する場合はオフィシャルサイトから、ポイントを利用せずHPCJ対象ホテルを予約する場合はHPCJサイトから予約している。</p>
<p>どちらのサイトで予約する場合でも、前日までキャンセル可能なFlexible Rateで予約をしている。（HPCJサイトでの予約は必然的にFlexible Rateになる。）</p>
<p>ホテルの宿泊料金は変動するので、予約した後で自分が予約した時の料金より安くなることがよくある。なので、予約後も料金を時々チェックして、予約時より安くなっていたらキャンセルして予約し直す、といったことをしている。</p>
<p>そこで、<a href="/blog/2025/01/28/1/">PlaywrightでGit scraping</a>という記事で紹介した<a href="https://github.com/mizzy/git-scraping-playwright-template">git-scraping-playwright-template</a>をベースにして、指定した日程のヒルトン宿泊にかかる料金やポイントを自動でウォッチできるやつをつくってみた。</p>
<p><a href="https://github.com/mizzy/git-scraping-hilton"><img src="https://opengraph.githubassets.com/efbe89083ae3d67f091dde51fe157d2da35426dc8300f8baab15b6c14eeb82f5/mizzy/git-scraping-hilton" height="200" /></a></p>
<p>config.tsで以下のようにウォッチしたいヒルトンホテルの場所や日程を指定する。</p>
<script src="https://gist.github.com/mizzy/bb16cb6f2b0de94f25534c1b60c23232.js"></script>
<p>今のところ、福岡、お台場、有明しか対応していない。対応ホテルを増やしたい場合は、config_type.tsの以下の部分に追加する。</p>
<script src="https://gist.github.com/mizzy/88978b078626b9c464648f451f01b20a.js"></script>
<p>各ホテルの料金やポイントは、<code>https://www.hilton.com/en/book/reservation/rooms/?ctyhocn=FUKHIHI&amp;arrivalDate=...</code><br />
というURLから取得しているが、<code>ctyhocn=FUKHIHI</code>にホテルコードらしきものが入っているので、ロケーション名とホテルコードのマッピングを上のコードで行っている。</p>
<p>ポイントは「Pay with Points」に表示されているもの、料金は「Quick Book」のところに表示されているFlexible Rateの料金を取得している。</p>
<p><img src="/images/2025/01/hilton-odaiba.png" alt="" /></p>
<p>同じ日程、同じ部屋タイプでも様々な料金プランがあるが、基本的にはFlexible Rateと連動してるはずなので、Flexible Rateをウォッチしておけば、価格の変動はわかるはず。</p>
<p>より正確な情報を得ようとするならば、自分の場合、ポイント、Flexible RateにHonors Discountが適用された価格、HPCJ価格（Flexible Rate * 0.75）の3つがあれば良いので、次はこれらの料金を取得できるよう改善する予定。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[PlaywrightでGit scraping]]></title>
        <link href="https://mizzy.org/blog/2025/01/28/1/"/>
        <updated>2025-01-28T21:21:41+09:00</updated>
        <id>https://mizzy.org/blog/2025/01/28/1/</id>
        <content type="html"><![CDATA[
<p>こちらのスライドに影響されて、Git scraping始めました。</p>
<script defer class="speakerdeck-embed" data-id="6844b3b0badf4a13a58f6528c58394d5" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"></script>
<p>親切なことに、テンプレートリポジトリを提供してくださっているので、さくっと始めることができました。</p>
<p><a href="https://github.com/ohbarye/git-scraping-template"><img src="https://opengraph.githubassets.com/eec38b4a69b9284604e4880ce91d56a6dd613cfdfcd1e7af8dfaa6d6ca55d5e6/ohbarye/git-scraping-template" height="300" /></a></p>
<p>ただ、スクレイピングしたいサイトの中にはJavaScript必須のものもあったので、そういったサイトにも対応できるよう、ohbaryeさんのテンプレートリポジトリを参考にして、PlaywrightでGit scrapingするためのテンプレートリポジトリを作成してみました。</p>
<p><a href="https://github.com/mizzy/git-scraping-playwright-template"><img src="https://opengraph.githubassets.com/ad5e0a080d1b88539dd3bc7e562cbe6e1c7e454a415566433117ccee07e23d29/mizzy/git-scraping-playwright-template" height="300" /></a></p>
<p>よろしければぜひご活用ください。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[アメックスの明細をZaimに同期するためのプログラム]]></title>
        <link href="https://mizzy.org/blog/2025/01/27/1/"/>
        <updated>2025-01-27T11:52:18+09:00</updated>
        <id>https://mizzy.org/blog/2025/01/27/1/</id>
        <content type="html"><![CDATA[
<p>家計簿ソフトに<a href="https://zaim.net/">Zaim</a>を利用しているのだけど、一時期アメックスとの連携に不具合があった。（今は解消している）</p>
<p><a href="https://content.zaim.net/questions/show/1109">アメリカン・エキスプレスの連携不具合について（2024/5/31 掲載）:よくある質問｜家計簿アプリ Zaim</a></p>
<p>幸いなことにZaimは、サポートはしていないながらも<a href="https://content.zaim.net/questions/show/338">CSVアップロード機能を提供</a>しているし、<a href="https://dev.zaim.net/">APIも提供</a>しているので、自力でなんとかするためのプログラムを作成した。</p>
<p>ひとつはアメックスからCSVを取得するための<a href="https://github.com/mizzy/amexcsv">amexcsv</a>というプログラム。</p>
<p><a href="https://github.com/mizzy/amexcsv"><img src="https://opengraph.githubassets.com/1de9675683c2ec1ebbea7d957f33022deb3b65cde74fc9411852abaaa307a7a5/mizzy/amexcsv" height="200" /></a></p>
<p>もうひとつはアメックスの明細CSVをZaimに同期するための<a href="https://github.com/mizzy/amexaim">amexaim</a>というプログラム。</p>
<p><a href="https://github.com/mizzy/amexaim"><img src="https://opengraph.githubassets.com/0d8975c687a5af67bf70dc3d5ff0670455ba279a3ab715684a780875f878098b/mizzy/amexaim" height="200" /></a></p>
<p>以下のように実行すると、アメックスのサイトから明細CSVをダウンロードして、Zaimに同期してくれる。</p>
<pre><code class="language-shell">$ amexcsv | amexaim
</code></pre>
<p>これを1日1回cronで実行している。時々、二要素認証が発生してCSVダウンロードに失敗してることがあるが、その場合は</p>
<pre><code class="language-shell">$ HEADLESS=false amexcsv | amezaim
</code></pre>
<p>と実行して、手動で二要素認証を通している。</p>
<p>現在は連携不具合は解消されているけれど、以下の理由で自前のプログラムを使い続けている。</p>
<ul>
<li>今後また連携できなくなる可能性がある（Zaim側ではなくアメックス側の問題で）</li>
<li>Zaimの連携機能を利用する場合、家族カードは口座グループに追加することができないのが少し不便</li>
</ul>
<p>プログラムの仕様上の問題で、完全には一致しない場合があるのだけど、事業の帳簿と違って完全一致させる必要はないので、満足してる。</p>
<p>ただ、API経由の登録だと、連携の履歴には未読としては表示されないので、そこだけは少し不便だけど、致命的ではないので、当分アメックスの明細は自前プログラムで同期するつもり。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Ruby製の静的サイトジェネレータをGoで再実装した]]></title>
        <link href="https://mizzy.org/blog/2025/01/26/1/"/>
        <updated>2025-01-26T19:32:42+09:00</updated>
        <id>https://mizzy.org/blog/2025/01/26/1/</id>
        <content type="html"><![CDATA[
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">ブログ3年ぐらい更新してなくて、もう少しマメに書くか、という機運になってきたので、ブログツール書き始めた。</p>&mdash; mizzy (@gosukenator) <a href="https://twitter.com/gosukenator/status/1883311289768063332?ref_src=twsrc%5Etfw">January 26, 2025</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>このブログは、マークダウン形式で記事を書いて、<a href="https://github.com/mizzy/ruby-nebel">Nebel</a>というRubyで実装したお手製の静的サイトジェネレータでHTMLに変換してGitHub Pagesでホストしている。</p>
<p>が、久々に書くか、と思ってNebelを動かしてみたところ、エラーで動かない。具体的には、ローカルでの確認用サーバのために利用しているeventmachine gemがビルドに失敗してインストールできない。</p>
<p>エラーの原因を調べて直すのもよいのだけど、13年ぐらい前につくって全然メンテしてないし、今となっては不要な機能もあるので、<a href="https://github.com/mizzy/nebel">Goで再実装した</a>。</p>
<p>といっても、Ruby版のすべての機能を実装したわけではない。Ruby版にはプラグイン機構があって、様々なプラグインが動いているが、プラグイン機構や各種プラグインは未実装。</p>
<p>例えばgistプラグインは</p>
<pre><code>{% gist 37401088bc6e3564addf7a27d698f6fb %}
</code></pre>
<p>と書いておくと</p>
<pre><code class="language-html">&lt;div&gt;&lt;script src='https://gist.github.com/37401088bc6e3564addf7a27d698f6fb.js?file='&gt;&lt;/script&gt;
&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;
</code></pre>
<p>といったHTMLに変換してくれる。自分でつくっておいてなんだけど、プラグインで変換しなくてもgistのページからEmbed用コードを簡単にコピーできるので、別にいらなかったな、と思ってる。</p>
<p>もしかしたら必要なプラグインもあるかもだけど、必要になってから実装すればいいやと思っている。</p>
<p>プラグイン利用前提で書いた過去記事はGo版では正しく変換してくれないことになるが、過去記事を再生成する必要はいまのところないので特に問題なさそう。</p>
<p>またRuby版には、コマンド一発で確認用のローカルサーバを立ち上げてブラウザで開き、記事を保存したら自動でHTMLに変換してブラウザも自動リロード、という、機能があるのだけど、これはあれば便利だけどなくても困らないので未実装。</p>
<p>とりあえず最低限必要な機能は実装でき、この記事もGo版で生成している。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Terraform State Refreshの高速化手法と実装]]></title>
        <link href="https://mizzy.org/blog/2022/03/24/1/"/>
        <updated>2022-03-24T12:00:00+09:00</updated>
        <id>https://mizzy.org/blog/2022/03/24/1/</id>
        <content type="html"><![CDATA[
<script type='module'>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  await mermaid.run({
    querySelector: 'pre > code.language-mermaid',
  });
</script>
<h2>TerraformのState</h2>
<p>TerraformのStateとは、Terraformで管理しているリソースの状態をJSONで記述したものであり、ファイルとして永続化されている。</p>
<p>Stateが何のためにあるのか、については<a href="https://www.terraform.io/language/state/purpose">オフィシャルな解説</a>があるので詳しく説明はしないが、Stateには主に以下の目的がある。</p>
<ul>
<li>Mapping to the Real World</li>
<li>Metadata</li>
<li>Performance</li>
<li>Syncing</li>
</ul>
<p>このエントリでは、Performanceに着目する。</p>
<hr />
<h2>State Refresh</h2>
<p>Terraformは、plan/applyを実行する際に、どのような変更を行う必要があるのかを決定するために、リソースの最新の状態を知る必要がある。 デフォルトの動作では、plan/applyを実行するたびに、すべてのリソースの最新の状態を取得しにいく。</p>
<p>これがState Refreshである。</p>
<p>State Refreshは、例えばAWS上のリソースを管理している場合は、リソースひとつひとつに対してAWSのAPIにリクエストを投げ、情報を取得する。また、リソースの種類によっては、ひとつのリソースに対して複数のAPIリクエストを投げることもある。</p>
<p>そのため、Terraformで管理しているリソースの数に応じてAPIリクエストの回数が増え、Refreshにかかる時間が増える。APIにはRate Limitもあるので、並列にリクエストを投げて高速化するのも限界がある。</p>
<p>管理しているリソースの数が少なければ、Refreshにかかる時間は問題にならないが、多い場合にはちょっとした変更を確認したいだけの場合でも、State Refreshで数分待たされることになる。</p>
<hr />
<h2>State Refreshを高速化する手法</h2>
<p>Terraformコードをサブディレクトリに分けStateを分割することで、State Refreshを高速にする、という手法が一般的に使われている。Stateの分割によりRefreshの高速化は見込めるが、細分化しすぎると運用管理が煩雑になる。</p>
<p>また、<a href="https://www.terraform.io/language/state/purpose">オフィシャルな解説</a>では、リソースの数が多い場合は、<code>-refresh=false</code>や<code>-target</code>オプションを利用することで、Refreshに時間がかかるのを回避する、といった記述がある。</p>
<p><code>-refresh=false</code>オプションの場合には、ファイルに永続化されたStateを正とみなし、APIリクエストを投げて最新の情報を取得するようなことはしない。また、<code>-target</code>オプションでは、指定したリソース（と依存関係のあるリソース）のみAPIリクエストを投げて最新の情報を取得するが、それ以外のリソースについては、ファイルに永続化されたStateを正とみなす。</p>
<p>しかし、<code>-refresh=false</code>は、Terraform外でリソースに変更があった場合はそれを検知できない。また、<code>-target</code>オプションはRefresh対象となるリソースをいちいち指定しないといけない上に、指定外のリソースについては、Terraform外で変更があっても検知できない。</p>
<p>そこで、State Refresh高速化のための手法として、以下の手法について考えてみる。</p>
<ul>
<li>Terraform外で変更されたリソースを予め永続化されたStateに反映しておく。</li>
<li>Terraform実行時にRefresh対象となるリソースを絞る。</li>
</ul>
<p>それぞれについて掘りさげる。</p>
<hr />
<h2>Terraform外で変更されたリソースを予め永続化されたStateに反映しておく（その1）</h2>
<p>ファイルに永続化されているStateが常に最新の状態になっていれば、<code>-refresh=false</code>オプションでRefreshをスキップしても、最新の状態が得られる。これにより、terraform plan/applyのState Refreshにかかる時間を0にすることができる。</p>
<p>これを実現する方法のひとつとして、以下のようなやり方が考えられる。</p>
<ul>
<li>リソースの変更を何らかの方法で検知する。</li>
<li>変更を検知したリソースがTerraform管理対象のリソースである場合、永続化されたStateに情報を反映する。</li>
</ul>
<p>AWSのリソースをTerraformで管理している、という前提の元では、具体的には以下のような実装が考えられる。</p>
<pre><code class="language-mermaid">flowchart LR
terraform[Lambda Function]
event[CloudWatch Events]
s3[S3 Bucket]
event -- 1 --&gt; terraform
terraform -- 2 --&gt; s3
</code></pre>
<ol>
<li>CloudWatch Eventsがリソースの変更イベントを発火</li>
<li>Lambda Functionが変更イベントを受け取り、変更されたリソースがTerraform管理下にある場合、<code>terraform refresh -target</code>でStateを更新して保存</li>
</ol>
<p>コンセプト実装として、<a href="https://github.com/mizzy/tfrefresh">tfrefresh</a>というものをつくってみた。</p>
<p>詳細は省くが、様々な面で実装や運用がかなり面倒ということがわかり、この手法はあまり実用的ではない、という判断に至った。</p>
<hr />
<h2>Terraform外で変更されたリソースを予め永続化Stateに反映しておく（その2）</h2>
<p>その1のやり方は、常にリソース変更イベントを監視し、リアルタイムに最新の情報を永続化Stateに反映する、という仕組みを維持管理する必要があり、運用の手間がかかる。</p>
<p>Terraformユーザから見れば、永続化Stateは常にリアルタイムに最新の状態を反映している必要はなく、Terraform実行時に最新の状態を反映していれば良い。そこで、AWSのリソースをTerraformで管理している、という前提で、次のような実装を考える。</p>
<pre><code class="language-mermaid">flowchart LR
cloudtrail[CloudTrail]
s3[S3 Bucket]
program[State Update Program]

cloudtrail -- 1 --&gt; program
program -- 2 --&gt; s3
</code></pre>
<ol>
<li>Terraform実行時にState Update Programが、永続化Stateの最終更新日時以降に変更されたリソースをCloudTrailログから取得。
<ul>
<li>このプログラムは、Terraformに組み込む、あるいはラッパースクリプト化するなどして、terraform plan/apply実行前に必ず動くようにする。</li>
</ul>
</li>
<li>State Update Programが、1.で取得したリソースに対して<code>terraform refresh -target</code>でStateを更新して保存。その後terraform plan/applyが実行される。</li>
</ol>
<p>このようにすると、Terraform実行前に、永続化Stateが最新の状態に更新されるため、<code>-refresh=false</code>オプションを利用して、State Refreshにかかる時間を0にすることができる。</p>
<p>こちらも詳細は省くが、そもそも永続化されたStateが最新更新日時を持っていないなど、Terraformの仕様上実装が困難ということがわかった。また、実装できたとしても、Terraform実行の直前にログからRefresh対象を判別し永続化Stateを更新するため、状況によってはかえって時間がかかる可能性もある。</p>
<hr />
<h2>Terraform実行時にRefresh対象となるリソースを絞る</h2>
<p>先に挙げた、予め永続化Stateに最新の情報を反映しておくのとは別なやり方として、Terraform実行時にRefresh対象となるリソースを絞るやり方を考える。</p>
<p>これは<a href="https://www.terraform.io/language/state/purpose">オフィシャルな解説</a>にある<code>-refresh=false</code>や<code>-target</code>オプションを利用した回避方法そのものであるが、オプションの指定を人が判断して行うのではなく、プログラムが判断する。</p>
<p>Refresh対象となるリソースをどのように判別するかであるが、ここでは、Terraformコードはバージョン管理システムで管理されており、ベースブランチのTerraformコードは常にapplyされた状態である、という前提の元、ベースブランチ上のファイルとカレントディレクトリ上のファイルを比較し、差分のあるリソースを抽出してRefresh対象とする。</p>
<p>これを行うためのツールとして、<a href="https://github.com/mizzy/tfdiff">tfdiff</a>というツールを実装してみた。tfdiffは、ベースブランチ上のファイルとカレントディレクトリ上のファイルを比較し、リソースに差分がない場合には<code>-refresh=false</code>という文字列を出力、差分がある場合には、該当リソースすべてについて<code>-target resource_name</code>という文字列を出力する。</p>
<p>tfdiffは<code>terraform plan $(tfdiff)</code>といった形で、terraformコマンドと組み合わせて利用する。</p>
<p>たとえば、tfdiffがリソースに差分がないと判断すれば、<code>terraform plan -refresh=false</code>が実行されるし、<code>aws_s3_bucket.foo</code>と<code>aws_iam_user.bar</code>に差分があると判断すれば、<code>terraform plan -target aws_s3_bucket.foo -target aws_iam_user.bar</code>が実行される。</p>
<p>これにより、Refresh対象となるリソースが必要なものだけに絞り込まれるので、Refresh時間を短縮することができる。</p>
<p>現在のtfdiffは250行ほどの雑なコードで、不十分なところも色々あるが、実装の労力に対して得られる効果は、先の2つの手法よりも大きく、利用のための敷居も低い。</p>
<p>ただしこのやり方では、差分のあるリソース、すなわち変更対象であるリソース（と依存関係にあるリソース）の情報は最新のものが得られるが、それ以外のリソースの情報は古いままである可能性が捨てきれない。冒頭で述べた、「Terraformは、plan/applyを実行する際に、どのような変更を行う必要があるのかを決定するために、リソースの最新の状態を知る必要がある。」という目的のためには十分であるが、Terraform以外のツール（<a href="https://github.com/kayac/ecspresso">ecspresso</a>や<a href="https://github.com/fujiwara/lambroll">lambroll</a>など）からStateを参照する際には、古い情報を参照してしまう可能性がある。</p>
<hr />
<h2>まとめ</h2>
<ul>
<li>Terraform State Refreshを高速化する手法や実装について、現在考えていることを整理してみた。</li>
<li>リアルタイム、あるいは必要なタイミング(Terraform実行時)にStateを最新の状態にする、という手法は、現在考えつく限りでは、実装や運用が困難である。</li>
<li>バージョン管理システムを活用して、Terraform実行時にRefresh対象を絞る、という手法は、前提条件はあるものの、実装や利用が比較的容易である。ただし、変更対象外のリソースはRefreshされないため、ファイルに永続化されたState上には古い情報が残る可能性がある。</li>
</ul>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Sock ShopのCloudFormation TemplateをTerraformとPulumiに移植した]]></title>
        <link href="https://mizzy.org/blog/2021/10/01/1/"/>
        <updated>2021-10-01T23:00:00+09:00</updated>
        <id>https://mizzy.org/blog/2021/10/01/1/</id>
        <content type="html"><![CDATA[
<p><a href="https://microservices-demo.github.io/">Microservices Demo: Sock Shop</a>の CloudFormation Templateを<a href="https://github.com/mizzy/sock-shop">TerraformとPulumiに移植</a>したので、それに関するメモを残しておく。</p>
<hr />
<h2>モチベーション</h2>
<p>最近仕事ではTerraformを触っている時間が一番多いので、研究もこの辺りのツールに関連する技術を対象とした方が良いのでは、と考えた。研究を行うためには、類似ツールの比較が必要だし、比較のためには、サンプルコード程度のものではなく、実際の環境に近い状態を再現できるコードが必要、というのが移植のモチベーションになっている。</p>
<hr />
<h2>移植元コード</h2>
<p><a href="https://microservices-demo.github.io/deployment/ecs.html">Deployment on Amazon EC/2 Container Service</a>にAmazon ECSへのデプロイ手順が載っているが、肝心のCloudFormation Templateは、<a href="https://github.com/microservices-demo/microservices-demo">元リポジトリ</a>ではDeplicated扱いで<a href="https://github.com/microservices-demo/microservices-demo/commit/b738dd548aae972">削除されている</a>。</p>
<p>なので、<a href="https://github.com/markfink-splunk/sock-shop">markfink-splunk/sock-shop: Deployments of the Weaveworks Sock Shop application instrumented with SignalFx.</a>にあるファイル(<a href="https://github.com/markfink-splunk/sock-shop/blob/master/ecs-fargate/cfn-stack-app-only.yaml">ecs-fargate/cfn-stack-app-only.yaml</a>)を移植元コードとして使うことにした。</p>
<hr />
<h2>デプロイ環境</h2>
<p>個人用に使っている検証用AWSアカウント、惰性で使っていてぐちゃぐちゃになってきたので、いったん不要なリソースを全削除して、<a href="https://aws.amazon.com/jp/organizations/">AWS Organizations</a>でマルチアカウント化、<a href="https://aws.amazon.com/jp/single-sign-on/">AWS Single Sign-On</a>で各アカウントにSSOできるようにした。</p>
<p>アカウント管理用のTerraformコード、最初はprivateにしていたけど、別に見えてまずい情報もないな、と思ったので<a href="https://github.com/mizzy/aws-accounts">publicにした</a>。</p>
<p>これにより、CloudFormation、Terraform、Pulumiそれぞれの検証環境をアカウントごと分離できるようにした。</p>
<hr />
<h2>CloudFormation Templateのデプロイ</h2>
<p>まずは大元となるCloudFormation Templateがデプロイできるものになっていないと話にならないので、ここから着手。元ファイルのままでは動かなかったり、そのままでは不便なところなどあったので、微修正している。差分は以下の通り。</p>
<p>{% gist 37401088bc6e3564addf7a27d698f6fb %}</p>
<hr />
<h2>Terraformへの移植</h2>
<p>CloudFormation Templateがデプロイできたところで、Terraformへの移植を行った。移植はおおまかには以下のような手順で行った。</p>
<ol>
<li>リソースをひとつ選び、Terraformコードで必須Argumentだけ指定したリソースを定義。</li>
<li>terraform importでCloudFormation用アカウント上のリソースをimport。</li>
<li>terraform planでCloudFormation用アカウント上のリソースとの差分を確認し、差分がなくなるよう必須以外のArtumentsを記述。</li>
<li>差分がなくなったらTerraform用アカウントにterraform applyしてリソースを作成。</li>
</ol>
<p>上記の作業を80ほどあるリソース全てに対して行った。</p>
<p><a href="https://github.com/GoogleCloudPlatform/terraformer">Terraformer</a>はいまいち使い勝手が悪いし、ひとつひとつどのようなリソースがあるか確認しておいた方が、後々捗りそうなので、人力で移植した。</p>
<p>先日行われた<a href="https://events.hashicorp.com/hashitalksjapan">HashiTalks: 日本</a>での、Quipperの鈴木さんのプレゼンで知った<a href="https://github.com/tfmigrator/tfmigrator">tfmigrator</a>を使えば、Terraformerのいまいちさを補えたっぽいので、今度機会があれば使ってみたい。</p>
<p>Terraformerがどういまいち使い勝手が悪いのか、とか、tfmigratorの使い方なんかは、<a href="https://techblog.szksh.cloud/tfmigrator/">鈴木さんのブログエントリ</a>に詳しく書いてあるので、興味ある方はこちらからどうぞ。</p>
<p>移植の最終確認として、Terraform用アカウントにapplyしたリソースをいったんdestroyして、最初から全リソースのapplyを行った。</p>
<p>が、上記手順4で「差分がなくなるよう必須以外のArgumentsを記述」とあるが、planで差分がなくなっても、別アカウントにapplyすると、明示してないArgumentが原因でうまくapplyできないリソースがあったので、その辺りの修正を行った。</p>
<hr />
<h2>Pulumiへの移植</h2>
<p>Pulumiへの移植も、Terraformへの移植と同様に、CloudFormation用アカウント上のリソースをひとつひとつインポートしながら進めていった。</p>
<p><a href="https://www.pulumi.com/tf2pulumi/">tf2pulumi</a>や<a href="https://www.pulumi.com/cf2pulumi/">cf2pulumi</a>といったツールもオフィシャルに提供されているけど、自分がわかりやすいようにコードやファイルを分割したかったので、これらのツールは使わなかった。</p>
<p>PulumiはTypeScript、JavaScript、Python、Go、C#から記述言語が選べるが、この中で一番慣れているGoで記述を行った。</p>
<p><a href="https://www.pulumi.com/docs/guides/adopting/import/">Pulumiのリソースインポート</a>は、Terraformと違いコードの生成まで行ってくれる。</p>
<p>たとえば、</p>
<pre><code> $ pulumi import aws:cloudwatch/logGroup:LogGroup \
  sock_shop \
  sock-shop
</code></pre>
<p>といったコマンドでCloudWatch Logs log groupをインポートすると、以下のようなコードを吐いてくれる。</p>
<p>{% gist 98fa264604cfd23bee559e83499f4cda %}</p>
<p>ただ、<code>pulumi import</code>ではエラーになってうまくインポートできない場合もあり、そういう場合は、先に以下の様なコードを書いてから、<code>pulumi up</code>を実行してインポートした。最後の<code>pulumi.Import()</code>がポイント。</p>
<p>{% gist 6aad2ff46fe3045f05c5c2f9a52a5c78 %}</p>
<p>また、希に<code>pulumi import</code>が吐くコードが間違っていることもあって、そういう場合は手で修正を行った。</p>
<p>Pulumi、サンプルコード程度しか触ったことがなかったけど、今回の移植作業でだいぶ把握できた気がする。</p>
<hr />
<h2>まとめ</h2>
<p>最初の方でもリンクを張っているけど、移植したコードは<a href="https://github.com/mizzy/sock-shop">ここに置いてあります</a>。</p>

]]></content>
    </entry>

</feed>
