<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Gosuke Miyashita]]></title>
    <link href="https://mizzy.org/atom.xml" rel="self"/>
    <link href="https://mizzy.org/"/>
    <updated>2026-01-29T22:07:30+09:00</updated>
    <id>https://mizzy.org/</id>
    <author>
        <name><![CDATA[Gosuke Miyashita]]></name>
    </author>
    <generator uri="https://github.com/mizzy/nebel/">Nebel</generator>

    <entry>
        <title type="html"><![CDATA[Carina aws providerとawscc provider]]></title>
        <link href="https://mizzy.org/blog/2026/01/29/2/"/>
        <updated>2026-01-29T22:07:30+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/29/2/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>に、aws providerに加えてawscc providerを実装してみた。</p>
<hr />
<h2>背景</h2>
<p>以前、<a href="https://mizzy.org/blog/2026/01/24/2/">AWS Cloud Control APIは遅い？</a>という記事で、Cloud Control APIは遅いので採用をやめた、と書いた。しかし、その後考えが変わった。</p>
<p>Cloud Control APIには以下のメリットがある。</p>
<ul>
<li>CloudFormationと同じリソースモデルを使っているため、リソースのスキーマが公式に定義されている</li>
<li>新しいリソースタイプやプロパティが追加された場合、CloudFormationのスキーマが更新されれば自動的にサポートできる</li>
<li>統一されたAPIで様々なリソースを操作できる</li>
</ul>
<p>確かに遅いが、遅さが許容できるユースケースもあるはずだし、もっと多くのリソースを扱ってみると、実はCloud Control APIの方が便利、という場面も出てくるかもしれない。</p>
<p>また、両方のプロバイダを用意しておけば、ユーザーがユースケースに応じて選択できる。</p>
<p>というわけで、aws provider（直接SDKを使う高速な方式）とawscc provider（Cloud Control APIを使う方式）の両方を実装しはじめた。</p>
<hr />
<h2>DSL構文</h2>
<h3>awsプロバイダ</h3>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">aws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>                 <span class="o">=</span> <span class="s2">&#34;example-vpc&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span>           <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_support</span>   <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_hostnames</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">instance_tenancy</span>     <span class="o">=</span> <span class="nc">aws.vpc</span><span class="p">.</span><span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><h3>awsccプロバイダ</h3>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">awscc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">awscc</span><span class="p">.</span><span class="nv">vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>                 <span class="o">=</span> <span class="s2">&#34;cloudcontrol-vpc&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span>           <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_support</span>   <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">enable_dns_hostnames</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">instance_tenancy</span>     <span class="o">=</span> <span class="nv">awscc</span><span class="p">.</span><span class="nv">vpc</span><span class="p">.</span><span class="err">I</span><span class="nv">nstance</span><span class="err">T</span><span class="nv">enancy</span><span class="p">.</span><span class="nv">dedicated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>基本的な構文は同じだが、以下の点が異なる。</p>
<ul>
<li>プロバイダ名が<code>aws</code>と<code>awscc</code></li>
<li>リソースタイプが<code>aws.vpc</code>と<code>awscc.vpc</code></li>
<li>enum値の名前空間が<code>aws.vpc.InstanceTenancy</code>と<code>awscc.vpc.InstanceTenancy</code></li>
</ul>
<p><code>aws</code>と<code>awscc</code>を置換するだけで切り替えられるようになっている。今後追加するリソースタイプも、基本的には両方とも同じスキーマで定義できるようにして、簡単に切り替えられるようにする予定。そうすることで、どちらがどういうユースケースに適しているかを試しやすくなる。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Nebelにシンタックスハイライト機能を追加した]]></title>
        <link href="https://mizzy.org/blog/2026/01/29/1/"/>
        <updated>2026-01-29T18:55:03+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/29/1/</id>
        <content type="html"><![CDATA[
<p>最近このブログは、<a href="https://github.com/mizzy/carina">Carina</a>の開発進捗報告の場と化して更新頻度が上がっているので、ブログ自体にも手を入れていっている。</p>
<p>2日前には<a href="https://mizzy.org/blog/2026/01/27/2/">OGP画像自動生成機能を追加した</a>が、今回はコードのシンタックスハイライト機能を追加した。</p>
<hr />
<h2>実装内容</h2>
<p>Markdownパーサとして使っている<a href="https://github.com/yuin/goldmark">goldmark</a>に、<a href="https://github.com/yuin/goldmark-highlighting">goldmark-highlighting</a>拡張を追加した。バックエンドには<a href="https://github.com/alecthomas/chroma">Chroma</a>というGo製のシンタックスハイライターを使っている。</p>
<p>テーマは<a href="https://catppuccin.com/">Catppuccin Mocha</a>を採用した。パステル調のダークテーマで、紫・青・緑・オレンジ・ピンクの柔らかい配色が特徴。ブログの背景が白なので、ダークテーマの方がコードブロックが目立つかな、と思って選んだ。</p>
<hr />
<h2>使い方</h2>
<p>Markdownで言語を指定してコードブロックを書くと、自動的にハイライトされる。</p>
<p>たとえばJSONを書くとこうなる。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;example&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>Bashだとこう。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="s2">&#34;Hello, World!&#34;</span>
</span></span></code></pre><hr />
<h2>Carina言語のサポート</h2>
<p>せっかくなので、開発中の<a href="https://github.com/mizzy/carina">Carina</a>用のカスタムレクサーも追加した。Chromaはカスタムレクサーを定義できるので、独自言語のハイライトも可能。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">backend</span> <span class="nv">s3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">bucket</span>      <span class="o">=</span> <span class="s2">&#34;my-carina-state&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">key</span>         <span class="o">=</span> <span class="s2">&#34;prod/carina.crnstate&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">encrypt</span>     <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">auto_create</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">main_vpc</span> <span class="o">=</span> <span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>       <span class="o">=</span> <span class="s2">&#34;main-vpc&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">cidr_block</span> <span class="o">=</span> <span class="s2">&#34;10.0.0.0/16&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>キーワード、文字列、真偽値、リソースタイプなどが適切にハイライトされる。</p>
<hr />
<h2>CSSの統一</h2>
<p>言語指定ありのコードブロックはChromaでハイライトされるが、言語指定なしのコードブロックは素の<code>&lt;pre&gt;</code>タグで出力される。見た目を統一するため、<code>base.css</code>の<code>pre</code>スタイルもCatppuccin Mochaテーマに合わせた。</p>
<p>また、コードブロックのフォントサイズを本文と同じ16pxにして、読みやすさを向上させた。</p>
<pre><code>言語指定なしのコードブロックも
同じダークブルー背景で表示される
</code></pre>
<hr />
<h2>まとめ</h2>
<ul>
<li>goldmark-highlighting（Chroma）でシンタックスハイライトを実装</li>
<li>Catppuccin Mochaテーマでパステル調のダークなコードブロックに</li>
<li>Carina言語用のカスタムレクサーを追加</li>
<li>フォントサイズを本文と統一して読みやすく</li>
<li>言語指定なしのコードブロックもスタイルを統一</li>
</ul>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carina State Management]]></title>
        <link href="https://mizzy.org/blog/2026/01/28/1/"/>
        <updated>2026-01-28T21:40:00+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/28/1/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>にS3バックエンドによるState管理機能を実装した。</p>
<hr />
<h2>背景</h2>
<p>Terraform Stateと同等の機能はやっぱり必要だよね、ということで、CarinaにもState管理機能とS3バックエンドを実装した。</p>
<hr />
<h2>DSL構文</h2>
<p>バックエンド設定は以下のように記述する。ほぼTerraformと同じ。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">backend</span> <span class="nv">s3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">bucket</span>      <span class="o">=</span> <span class="s2">&#34;my-carina-state&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">key</span>         <span class="o">=</span> <span class="s2">&#34;prod/carina.crnstate&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">encrypt</span>     <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="nv">auto_create</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p><code>auto_create = true</code>はTerraformにはない機能。Terraformでは、Stateを保存するS3バケットは事前に作成しておく必要がある。Carinaでは<code>auto_create</code>を有効にすると、初回<code>apply</code>時にバケットが自動作成され、さらにそのバケットのリソース定義が<code>.crn</code>ファイルに自動で追加される。</p>
<hr />
<h2>Stateファイル</h2>
<p>StateファイルはJSON形式で、以下のような構造になっている。とりあえずClaude Codeに適当に決めてもらった。後で色々変えることになると思う。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;serial&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;lineage&#34;</span><span class="p">:</span> <span class="s2">&#34;358893ec-5a07-49bf-acbc-940d9563c7f5&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;carina_version&#34;</span><span class="p">:</span> <span class="s2">&#34;0.1.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;resources&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;resource_type&#34;</span><span class="p">:</span> <span class="s2">&#34;s3.bucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;my-bucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;provider&#34;</span><span class="p">:</span> <span class="s2">&#34;aws&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;attributes&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;my-bucket&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;region&#34;</span><span class="p">:</span> <span class="s2">&#34;ap-northeast-1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;versioning&#34;</span><span class="p">:</span> <span class="s2">&#34;Enabled&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;protected&#34;</span><span class="p">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><ul>
<li><code>serial</code>: 変更のたびにインクリメントされる</li>
<li><code>lineage</code>: 状態ファイルの系譜を識別するUUID（誤上書き防止）</li>
<li><code>protected</code>: trueの場合、<code>destroy</code>で削除されない</li>
</ul>
<hr />
<h2>plan</h2>
<p><code>plan</code>実行時に、Stateバケットが作成されることが<code>Bootsrap Plan:</code>として表示される。</p>
<p><img src="/images/2026/01/carina-state-bootstrap.png" alt="carina plan の出力" /></p>
<hr />
<h2>apply</h2>
<p>apply実行時に、Stateバケットが自動作成される。</p>
<p><img src="/images/2026/01/carina-state-apply.png" alt="carina apply の出力" /></p>
<p>また、backendが定義されているファイルに、Stateバケットのリソース定義が自動追加される。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="c"># Auto-generated by carina (state bucket)</span>
</span></span><span class="line"><span class="cl"><span class="nc">aws.s3.bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">name</span>       <span class="o">=</span> <span class="s2">&#34;my-carina-state&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">versioning</span> <span class="o">=</span> <span class="s2">&#34;Enabled&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><hr />
<h2>destroy</h2>
<p>StateバケットはState内で<code>protected</code>フラグが設定されるため、通常の<code>destroy</code>では削除されない。</p>
<p><img src="/images/2026/01/carina-state-destroy.png" alt="carina destroy の出力" /></p>
<p>「⚠ s3.bucket.carina-state-test-mizzy (protected - will be skipped)」と表示され、destroy対象からスキップされる。</p>
<p>Stateバケットを削除したい場合は、<code>state bucket-delete</code>コマンドを使う。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ carina state bucket-delete &lt;bucket-name&gt; --force
</span></span></code></pre><hr />
<h2>state lock/unlock</h2>
<p>チーム開発にはstate lock/unlockは必要だよね、ってことでTerraformのようなstate lock/unlock機能も実装した。</p>
<hr />
<h2>今後</h2>
<p>Terraform Stateに関する不満として一番大きいのは、やはりstate refreshの速度だと思う。<a href="https://mizzy.org/blog/2022/03/24/1/">Terraform State Refreshの高速化手法と実装</a> という記事で、高速化するための手法や実装をいくつか挙げたが、あくまでもTerraformを前提としたものだった。Carinaではその前提が取っ払えるので、もっとよい形での高速化が実現できるかもしれないし、できないかもしれない。今後の課題として取り組んでいきたい。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[NebelにOGP画像自動生成機能を追加した]]></title>
        <link href="https://mizzy.org/blog/2026/01/27/2/"/>
        <updated>2026-01-27T19:08:09+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/27/2/</id>
        <content type="html"><![CDATA[
<p>tokuhiromさんの<a href="https://blog.64p.org/entry/2026/01/26/110749">ogp を設定した</a>という記事を読んで、そういえば自分もOGP対応しなきゃな、と思い出した。以前から対応しようと思いつつ、画像生成とか面倒だな、と後回しにしていた。でも今なら生成AIでシュッと対応できるな、と思ってやってみた。</p>
<p>ちなみにこのブログ記事もClaude Codeが書いたものをそのまま出している。</p>
<p>このブログの静的サイトジェネレータである<a href="https://github.com/mizzy/nebel">Nebel</a>に、OGP画像を自動生成する機能を追加した。</p>
<hr />
<h2>OGP画像とは</h2>
<p>OGP（Open Graph Protocol）画像は、SNSでURLをシェアしたときに表示されるサムネイル画像のこと。TwitterやFacebookなどでリンクを共有すると、タイトルや説明文と一緒に画像が表示される。</p>
<p>これまでこのブログにはOGP画像を設定していなかったので、SNSでシェアしてもデフォルトの味気ない表示になっていた。</p>
<hr />
<h2>実装内容</h2>
<p><code>nebel generate</code>を実行すると、各記事のタイトルからOGP画像（1200x630px）を自動生成するようにした。</p>
<ul>
<li><strong>サイズ</strong>: 1200x630px（OGP推奨サイズ）</li>
<li><strong>背景</strong>: ダークグレー（#333）</li>
<li><strong>テキスト</strong>: 記事タイトル（白色、中央配置）</li>
<li><strong>フォント</strong>: Noto Sans CJK JP Bold（日本語対応）</li>
</ul>
<p>生成される画像はこんな感じ。</p>
<p><img src="/blog/2026/01/27/2/ogp.png" alt="OGP画像のサンプル" /></p>
<hr />
<h2>使用ライブラリ</h2>
<p>Goで画像を生成するために<a href="https://github.com/fogleman/gg">fogleman/gg</a>というライブラリを使った。シンプルなAPIで2D描画ができるので、こういった用途にはちょうど良い。</p>
<p>日本語フォントには<a href="https://fonts.google.com/noto/specimen/Noto+Sans+JP">Noto Sans CJK JP</a>を使用。CJK（中国語・日本語・韓国語）に対応しているので、日本語タイトルも問題なく描画できる。</p>
<hr />
<h2>テンプレートの変更</h2>
<p>HTMLテンプレートには、OGPとTwitter Cardのメタタグを追加した。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="c">&lt;!-- OGP --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:title&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;{{ .Title }}&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;article&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:url&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;https://mizzy.org{{ .Path }}/&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:image&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;https://mizzy.org{{ .OGImagePath }}&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">property</span><span class="o">=</span><span class="s">&#34;og:site_name&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;Gosuke Miyashita&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- Twitter Card --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;twitter:card&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;summary_large_image&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;twitter:title&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;{{ .Title }}&#34;</span><span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;twitter:image&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;https://mizzy.org{{ .OGImagePath }}&#34;</span><span class="p">/&gt;</span>
</span></span></code></pre><p>これで、SNSでシェアしたときにタイトル入りの画像が表示されるようになる。</p>
<hr />
<h2>今後</h2>
<p>デザインは現状かなりシンプルなので、余裕があればもう少し凝ったものにしたい。ロゴを入れたり、グラデーション背景にしたり、といったあたりは比較的簡単にできそう。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carinaの型システムについて]]></title>
        <link href="https://mizzy.org/blog/2026/01/27/1/"/>
        <updated>2026-01-27T09:54:37+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/27/1/</id>
        <content type="html"><![CDATA[
<p>Terraformライクなツール<a href="https://github.com/mizzy/carina">Carina</a>をつくりはじめた動機のひとつに、「型システムの強化」がある。</p>
<p>Terraformではプリミティブな型（string, number, bool）に加えて、listやmap、objectなどの複合型がサポートされている。しかし、型システム自体はあまり強力ではない。</p>
<p>例えば、regionやcidr_blockのような特定のドメインに特化した型は存在しない。そのため、これらの値を扱う際には単なるstring型として扱われ、誤った値が設定される可能性がある。誤った設定をした場合、validateやplanで気づけるのであればまだ良いが、planが通ってしまい、apply時にエラーになってはじめて間違いが発覚することもある。</p>
<p>これを防ぐために、Carinaではドメイン固有型の導入を試している。現在実装しているものとして、region型やcidr型がある。これらの型は、それぞれのドメインに特化したバリデーションロジックを持っており、不正な値が設定された場合には即座にエラーを返す。</p>
<p>例えば、誤ってリージョンを指定すべきところにアベイラビリティゾーンを指定したとする。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="k">aws</span> {
</span></span><span class="line"><span class="cl"><span class="n">  region</span> <span class="o">=</span> <span class="s2">&#34;ap-northeast-1a&#34;</span>
</span></span><span class="line"><span class="cl">}
</span></span></code></pre><p>Terraformではさすがに<code>plan</code>は通らないが、<code>validate</code>は通る。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ terraform validate
</span></span><span class="line"><span class="cl">Success! The configuration is valid.
</span></span></code></pre><p>Carinaもproviderの定義はTerraformと同じように記述するが、<code>validate</code>で以下のようなエラーが返る。</p>
<pre class="chroma"><code><span class="line"><span class="cl">Error: provider aws: Validation failed: Invalid region <span class="s1">&#39;ap-northeast-1a&#39;</span>, expected one of: ap-northeast-1, ap-northeast-2, ap-northeast-3, ap-southeast-1, ap-southeast-2, ap-south-1, us-east-1, us-east-2, us-west-1, us-west-2, eu-west-1, eu-west-2, eu-west-3, eu-central-1, eu-north-1, ca-central-1, sa-east-1 or DSL format like aws.Region.ap_northeast_1
</span></span></code></pre><p>このようにCarinaでは、型システムを強化することで、より早い段階で設定ミスを検出できるようにしたい、と考えている。</p>
<p>また、CarinaではAWSリージョンはEnum型として定義されているため、以下のようにリージョンを指定することもできる。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">provider</span> <span class="nv">aws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">region</span> <span class="o">=</span> <span class="no">aws.Region.ap_northeast_1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p>更にLSPもサポートしているため、IDE上で補完候補としてリージョンの一覧が表示される。</p>
<p><img src="/images/2026/01/carina-region-completion.png" alt="リージョンの補完候補" /></p>
<p>誤った文字列を指定している場合も、IDE上でエラーが表示される。</p>
<p><img src="/images/2026/01/carina-region-error.png" alt="IDEでのエラー表示" /></p>
<p>もう一つの例として、cidr型を紹介する。cidr型はCIDR表記のIPアドレスブロックを表す型で、不正なCIDR表記が指定された場合にはエラーを返す。</p>
<p>例えば、以下のように不正なプレフィックス長を指定したとする。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">main_vpc</span> <span class="o">=</span> <span class="nc">aws.vpc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">name</span>       <span class="o">=</span> <span class="s2">&#34;main-vpc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cidr_block</span> <span class="o">=</span> <span class="s2">&#34;10.0.0.0/33&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre><p><code>carina validate</code>を実行すると、以下のようなエラーが返る。</p>
<pre><code>Error: vpc.main-vpc: Validation failed: Invalid prefix length '33': must be 0-32
</code></pre>
<p>Terraformでもvalidateで同様のエラーが返るが、IntelliJ IDEAのTerraformプラグインではCIDR表記のフォーマットエラーが検出されない。CarinaのLSPでは、IDE上で以下のようにエラーが表示される。</p>
<p><img src="/images/2026/01/carina-cidr-error.png" alt="cidr_blockのエラー表示" /></p>
<p>まったくCIDR表記として成り立っていない場合も、当然ながらIDE上でエラーが表示される。</p>
<p><img src="/images/2026/01/carina-cidr-format-error.png" alt="cidr_blockのフォーマットエラー表示" /></p>
<p>cidr型でもregion型と同様に、補完候補として一般的なCIDR表記が表示される。</p>
<p><img src="/images/2026/01/carina-cidr-completion.png" alt="cidr_blockの補完候補" /></p>
<p>さらに別の例として、S3バケットの<code>versioning_configuration</code>属性を紹介する。<code>versioning_configuration</code>はS3バケットのバージョニング設定を表すオブジェクト型で、<code>status</code>フィールドには<code>Enabled</code>または<code>Suspended</code>のいずれかを文字列で指定する必要がある（<code>Disabled</code>もあるがこれはちょっと特殊な値）。誤った文字列を指定すると、validateやplanでは不正な値が検出されるが、IDE上ではエラーや補完候補が表示されないため、あれ、Enableだっけ？Enabledだっけ？と迷ったら公式ドキュメントを確認する必要がある。</p>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="k">resource</span> <span class="s2">&#34;aws_s3_bucket_versioning&#34; &#34;versioning_example&#34;</span> {
</span></span><span class="line"><span class="cl"><span class="n">  bucket</span> <span class="o">=</span> <span class="k">aws_s3_bucket</span><span class="p">.</span><span class="k">example</span><span class="p">.</span><span class="k">id</span>
</span></span><span class="line"><span class="cl">  <span class="k">versioning_configuration</span> {
</span></span><span class="line"><span class="cl"><span class="n">    status</span> <span class="o">=</span> <span class="s2">&#34;Enabled&#34;</span>
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre><p>Carinaでは、このstatusフィールドをEnum型として定義しているため、以下のように補完候補として&quot;Enabled&quot;と&quot;Suspended&quot;が表示される。</p>
<p><img src="/images/2026/01/carina-s3-versioning-completion.png" alt="S3バケットのversioning補完" /></p>
<p>エディタ上でのエラー表示や自動補完については、今は生成AIが基本的にコードを書いてくれるのであまり気にする必要はないかもしれない。しかし、型システムが強力であればあるほど、生成AIがより正確なコードを生成できるようになり、早い段階で間違いに気づけるようになるはず。</p>
<p>型システムを強化するためには、各リソースの属性やその型情報を正確に把握する必要がある。AWSの場合、CloudFormationのリソースタイプスキーマを利用することで、各リソースの属性情報を取得できる。例えば、以下のコマンドを実行すると、S3バケットリソースのスキーマ情報が取得できる。</p>
<pre class="chroma"><code><span class="line"><span class="cl">aws cloudformation describe-type <span class="se">\
</span></span></span><span class="line"><span class="cl">      --type RESOURCE <span class="se">\
</span></span></span><span class="line"><span class="cl">      --type-name AWS::S3::Bucket <span class="se">\
</span></span></span><span class="line"><span class="cl">      --query <span class="s2">&#34;Schema&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">      --output text
</span></span></code></pre><p>これを元にCarinaで型定義を自動生成するなり、AIに生成させるなりすれば、型システムの強化がより容易になると考えている。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[carina planで依存関係を可視化]]></title>
        <link href="https://mizzy.org/blog/2026/01/25/2/"/>
        <updated>2026-01-25T15:14:36+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/25/2/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>の<code>plan</code>コマンドで、リソース間の依存関係をツリー構造で表示できるようにした。</p>
<p><img src="/images/2026/01/carina-plan.png" alt="carina plan の出力" /></p>
<p>Terraformの<code>plan</code>コマンドは、作成・変更・削除されるリソースがフラットなリストで表示される。どのリソースが作成されるかはわかるが、リソース間の依存関係は出力からは読み取れない。</p>
<p>Carinaの<code>plan</code>では、依存関係に基づいてリソースがツリー構造で表示される。上の例だと、VPCの下にSecurity Groupがあり、その下にIngress Ruleがある、という階層構造が一目でわかる。</p>
<p>これにより、planの出力を見るだけで、リソース間の依存関係を把握できる。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[Carina Modules]]></title>
        <link href="https://mizzy.org/blog/2026/01/25/1/"/>
        <updated>2026-01-25T12:59:31+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/25/1/</id>
        <content type="html"><![CDATA[
<p><a href="/blog/2026/01/24/1/">昨日の記事</a>で紹介した<a href="https://github.com/mizzy/carina">Carina</a>に、モジュール機能を実装した。</p>
<hr />
<h2>背景</h2>
<p><a href="/blog/2025/11/17/1/">YAPC::Fukuoka 2025での発表</a>で、インフラコードのモジュール化の難しさについて話した。</p>
<script defer class="speakerdeck-embed" data-id="facd81a255fb4c32ab2d80c559f1ede1" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"></script>
<p>ここで挙げた問題のひとつが「内部構造の把握と依存関係の追跡が困難」という点。Terraformのモジュールは中身を見ないと何が作られるかわからないし、依存関係も追いづらい。planを実行してみれば、どんなリソースがつくられるかはわかるが、モジュールを呼び出すためのコードを書かないといけなくて面倒。また、つくられるリソースは表示されるが、リソース間の依存関係はplanの出力からはわからない。</p>
<p>この問題を解決するために、Carinaには<code>module info</code>というコマンドを実装した。</p>
<hr />
<h2>module info コマンド</h2>
<p><code>module info</code>コマンドを実行すると、モジュールの情報が以下のように表示される。</p>
<p><img src="/images/2026/01/carina-module-info.png" alt="module info の出力" /></p>
<p>3つのセクションに分かれている。</p>
<h3>REQUIRES</h3>
<p>モジュールが必要とする入力を表示する。</p>
<pre><code>vpc: ref(aws.vpc)  (required)
cidr_blocks: list(cidr)  (required)
enable_https: bool = true
</code></pre>
<p>型情報と、必須かどうか、デフォルト値があるかどうかがわかる。</p>
<h3>CREATES</h3>
<p>モジュールが作成するリソースをツリー構造で表示する。</p>
<pre><code>input { vpc: ref(aws.vpc) }
└── web_sg: aws.security_group
    ├── http: aws.security_group.ingress_rule
    └── https: aws.security_group.ingress_rule
</code></pre>
<p>入力として受け取った<code>vpc</code>を起点に、どのリソースがどのリソースに依存しているかが視覚的にわかる。</p>
<h3>EXPOSES</h3>
<p>モジュールが外部に公開する出力を表示する。</p>
<pre><code>security_group: ref(aws.security_group)
  ← from: web_sg
</code></pre>
<p>出力の型と、その出力がモジュール内のどのリソースから来ているかがわかる。</p>
<hr />
<h2>今後</h2>
<p>まだ少ないリソース数と単純な依存関係でしか試していないが、モジュールで定義されているリソース構造を把握するのに役立ちそう。リソース数が増えたり、依存関係が複雑になったりするとどうなるか、引き続き試しながら改善していきたい。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[AWS Cloud Control APIは遅い？]]></title>
        <link href="https://mizzy.org/blog/2026/01/24/2/"/>
        <updated>2026-01-24T18:40:23+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/24/2/</id>
        <content type="html"><![CDATA[
<p><a href="https://github.com/mizzy/carina">Carina</a>の開発中に、AWS Cloud Control APIが遅いことに気づいた。</p>
<hr />
<h2>Cloud Control APIを試した背景</h2>
<p>CarinaでAWSリソースを扱うにあたり、最初はaws-sdk-s3を使ってS3バケットの操作を実装していた。ただ、この方法だとリソースタイプごとに個別実装が必要になる。S3、EC2、IAM...とAWSのサービスは膨大にあるので、全部個別に実装するのは大変だ。生成AIがあるとはいえ、もっと楽にできないかと考えた。</p>
<p>そこで<a href="https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/what-is-cloudcontrolapi.html">Cloud Control API</a>を使うことを考えた。Cloud Control APIは、CloudFormationと同じリソースハンドラーを使った統一的なAPIで、様々なAWSリソースをCRUD操作できる。</p>
<p>Cloud Control APIを使う大きなメリットとして、CloudFormationのJSON Schemaが公開されていることがある。例えばS3バケットのスキーマは以下のコマンドで取得できる。</p>
<pre class="chroma"><code><span class="line"><span class="cl">aws cloudformation describe-type --type RESOURCE <span class="se">\
</span></span></span><span class="line"><span class="cl">  --type-name AWS::S3::Bucket --query <span class="s1">&#39;Schema&#39;</span> --output text
</span></span></code></pre><p>このスキーマを使えば、<a href="https://github.com/oxidecomputer/typify">typify</a>でRustの型を自動生成できる。生成した型を使ってバリデーションすれば、リソースごとに手動でバリデーションロジックを書く必要がなくなる。</p>
<p>というわけで、Cloud Control APIを使うよう<a href="https://github.com/mizzy/carina/pull/2">実装してみた</a>。</p>
<hr />
<h2>問題発覚</h2>
<p>S3バケットの<code>versioning_configuration</code>を変更する<code>apply</code>を実行したところ、完了までに20秒以上かかった。単純なプロパティ変更なのに遅すぎるのでは、と思って調べてみた。</p>
<hr />
<h2>計測結果</h2>
<p>直接S3 APIを叩いた場合と、Cloud Control APIを叩いた場合で比較してみた。</p>
<h3>直接S3 API</h3>
<pre class="chroma"><code><span class="line"><span class="cl">$ <span class="nb">time</span> aws s3api put-bucket-versioning <span class="se">\
</span></span></span><span class="line"><span class="cl">  --bucket carina-test-logs-mizzy-2026 <span class="se">\
</span></span></span><span class="line"><span class="cl">  --versioning-configuration <span class="nv">Status</span><span class="o">=</span>Suspended
</span></span></code></pre><p>所要時間: <strong>約0.4〜0.5秒</strong></p>
<h3>Cloud Control API</h3>
<pre class="chroma"><code><span class="line"><span class="cl"><span class="nv">RESULT</span><span class="o">=</span><span class="k">$(</span>aws cloudcontrol update-resource <span class="se">\
</span></span></span><span class="line"><span class="cl">  --type-name <span class="s2">&#34;AWS::S3::Bucket&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">  --identifier <span class="s2">&#34;carina-test-logs-mizzy-2026&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">  --patch-document <span class="s1">&#39;[{&#34;op&#34;:&#34;replace&#34;,&#34;path&#34;:&#34;/VersioningConfiguration&#34;,&#34;value&#34;:{&#34;Status&#34;:&#34;Enabled&#34;}}]&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">REQUEST_TOKEN</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$RESULT</span><span class="s2">&#34;</span> <span class="p">|</span> jq -r <span class="s1">&#39;.ProgressEvent.RequestToken&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">START</span><span class="o">=</span><span class="k">$(</span>date +%s<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> true<span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="nv">STATUS</span><span class="o">=</span><span class="k">$(</span>aws cloudcontrol get-resource-request-status <span class="se">\
</span></span></span><span class="line"><span class="cl">    --request-token <span class="s2">&#34;</span><span class="nv">$REQUEST_TOKEN</span><span class="s2">&#34;</span> <span class="p">|</span> jq -r <span class="s1">&#39;.ProgressEvent.OperationStatus&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;[</span><span class="k">$((</span> <span class="k">$(</span>date +%s<span class="k">)</span> <span class="o">-</span> START <span class="k">))</span><span class="s2">s] </span><span class="nv">$STATUS</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$STATUS</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="s2">&#34;SUCCESS&#34;</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$STATUS</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="s2">&#34;FAILED&#34;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break</span>
</span></span><span class="line"><span class="cl">  sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span></code></pre><p>完了までの所要時間: <strong>約23秒</strong></p>
<hr />
<h2>なぜ遅いのか</h2>
<p>Cloud Control APIはCloudFormationと同じリソースハンドラーを使っており、内部的にリソースの整合性チェックや安定化待ち（resource stabilization）を行っているようだ。</p>
<p>AWSの公式ブログ<a href="https://aws.amazon.com/blogs/devops/how-we-sped-up-aws-cloudformation-deployments-with-optimistic-stabilization/">How we sped up AWS CloudFormation deployments with optimistic stabilization</a>でも、CloudFormationのデプロイが遅い理由として「resource stabilization」に時間がかかることが説明されている。</p>
<hr />
<h2>まとめ</h2>
<table>
<thead>
<tr>
<th>方式</th>
<th>所要時間</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接S3 API</td>
<td>約0.5秒</td>
</tr>
<tr>
<td>Cloud Control API</td>
<td>約23秒</td>
</tr>
</tbody>
</table>
<p>Cloud Control APIは統一的なインターフェースで様々なリソースを扱えるメリットがあるが、個別のAPIを直接叩くより大幅に遅い。速度が重要な場合は、リソースタイプごとに直接SDKを使う方がよさそう。</p>
<p>Carinaでの採用はやめた。</p>

]]></content>
    </entry>

    <entry>
        <title type="html"><![CDATA[CarinaというTerraformライクなツールをつくりはじめた]]></title>
        <link href="https://mizzy.org/blog/2026/01/24/1/"/>
        <updated>2026-01-24T13:47:59+09:00</updated>
        <id>https://mizzy.org/blog/2026/01/24/1/</id>
        <content type="html"><![CDATA[
<h2>きっかけ</h2>
<p>gfxさんの<a href="https://gfx.hatenablog.com/entry/2026/01/23/212644">個人が静的型付き言語のコンパイラをゼロから作れる時代が来た！</a>という記事を読んで、自分も何か、以前だったらつくろうと思っても面倒で手が出なかったようなものをつくってみよう、と思ってつくりはじめた。</p>
<p>自分のことを知ってる方ならご存じかと思うが、自分はInfrastructure as Codeが大好きで、普段からIaCのことばかり考えている。最近だとこんなことを考えて発表した。</p>
<script defer class="speakerdeck-embed" data-id="facd81a255fb4c32ab2d80c559f1ede1" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"></script>
<p>Terraformは好きで、公私ともにとてもお世話になっているのだが、こうなっているといいな、と思う点が色々ある。だが、Terraformはそれなりに歴史も実績もあるツールで、とてもよくできているので、自分でいちからつくって、Terraformと同レベルで使えるようになるまで育てるのは大変すぎるな、と思っていた。が、gfxさんの記事を読んで、今ならいけそうだな、と思ってつくりはじめた。</p>
<hr />
<h2>Carinaについて</h2>
<p><a href="https://github.com/mizzy/carina">Carina</a>は、Rustで実装したTerraformライクなインフラ管理ツール。</p>
<p>基本的にはTerraformと同じなんだけど、今のところ違う点を挙げると以下のような感じ。</p>
<ul>
<li>独自DSLによるインフラ定義
<ul>
<li>今のところHCLをかなり参考にしているけど、微妙に違う部分もある</li>
<li>Terraformを使っていて、もっとこうなってるといいのにな、と思う部分を改善していく予定</li>
</ul>
</li>
<li>型がより厳密に定義されている
<ul>
<li>例えばTerraform aws providerではregionは文字列で<code>ap-northeast-1</code>と書くが、Carina aws providerではenumで定義されていて、<code>aws.Region.ap_northeast_1</code>のように書く</li>
</ul>
</li>
</ul>
<p>ちなみに、自分はツールに名前をつけるときは天体に関連する言葉を使うことが多い。Carinaはりゅうこつ座のことで、竜骨は船の重要な骨格部分。インフラを支えるツールにふさわしいかな、と思ってこの名前にした。</p>
<hr />
<h2>なぜRustか</h2>
<p>言語選定はClaude Codeと相談して決めた。候補としてはRust、Go、TypeScriptあたりが挙がった。</p>
<p>Rustを選んだ理由としては、</p>
<ul>
<li>強力な型システムで信頼性の高いインフラツールを作れる</li>
<li>パーサーライブラリのpestが使いやすい</li>
<li>非同期処理のエコシステム（tokio）が成熟している</li>
<li>AWS SDK for Rustが利用可能</li>
<li>シングルバイナリで配布しやすい</li>
</ul>
<p>といったあたりをClaude Codeが挙げてくれたけど、まあなんとなくRust使ってみるか、ぐらいで決めた。自分はRustにあまり馴染みがないけど、Claude Codeに書いてもらうなら問題ないだろうし、Rustを学ぶ良い機会になるかな、と。</p>
<hr />
<h2>DSL</h2>
<p><code>.crn</code>という拡張子のファイルにインフラを定義する。</p>
<pre><code>provider aws {
    region = aws.Region.ap_northeast_1
}

# 匿名リソース
aws.s3.bucket {
    name = &quot;my-app-logs&quot;
    region = aws.Region.ap_northeast_1
    versioning = true
    expiration_days = 90
}

# 名前付きリソース
let backup = aws.s3.bucket {
    name = &quot;my-app-backup&quot;
    region = aws.Region.ap_northeast_1
}
</code></pre>
<p>Terraformと似たような感じだけど、以下の点が異なる。</p>
<ul>
<li>リソースタイプの指定が<code>aws.s3.bucket</code>のようにドット区切り
<ul>
<li>Terraformの場合は<code>aws_s3_bucket</code>のようにアンダースコア区切り</li>
</ul>
</li>
<li>名前付きリソースは<code>let</code>で宣言
<ul>
<li>Terraformの場合は<code>resource &quot;aws_s3_bucket&quot; &quot;backup&quot;</code>のように書くし、リソース名が必須になるが、Carinaでは、他リソースから参照する必要がなければ、匿名にできるようにしている</li>
</ul>
</li>
<li>Data Sourceのことはまだ考えてなかったので、区別するためのキーワードが必要になりそうだけど、まだ決めていない</li>
</ul>
<p>Terraformだと、<code>resource &quot;aws_s3_bucket&quot; &quot;my_app_logs&quot;</code>のように書くが、リソースタイプがアンダースコア区切りなので、それに合わせてリソース名もアンダースコア区切りにすべきか、それともハイフン区切りにすべきか、といつも悩む。別にどちらでもいいんだけど、どちらでもいいということは、その時々で判断がぶれてしまうので、ぶれないようにしたい、と思ったのがこのような設計にした理由の一つ。</p>
<hr />
<h2>使い方</h2>
<p>Terraformと同様に<code>validate</code>、<code>plan</code>、<code>apply</code>というコマンドがある。</p>
<pre class="chroma"><code><span class="line"><span class="cl">$ carina validate example.crn
</span></span><span class="line"><span class="cl">Validating...
</span></span><span class="line"><span class="cl">✓ <span class="m">2</span> resources validated successfully.
</span></span><span class="line"><span class="cl">  • s3_bucket.my-app-logs
</span></span><span class="line"><span class="cl">  • s3_bucket.my-app-backup
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ carina plan example.crn
</span></span><span class="line"><span class="cl">Using AWS provider <span class="o">(</span>region: ap-northeast-1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Execution Plan:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  + s3_bucket.my-app-logs
</span></span><span class="line"><span class="cl">      name: <span class="s2">&#34;my-app-logs&#34;</span>
</span></span><span class="line"><span class="cl">      versioning: <span class="nb">true</span>
</span></span><span class="line"><span class="cl">      expiration_days: <span class="m">90</span>
</span></span><span class="line"><span class="cl">  + s3_bucket.my-app-backup
</span></span><span class="line"><span class="cl">      name: <span class="s2">&#34;my-app-backup&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Plan: <span class="m">2</span> to add, <span class="m">0</span> to change, <span class="m">0</span> to destroy.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ carina apply example.crn
</span></span><span class="line"><span class="cl">Applying changes...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ✓ Create s3_bucket.my-app-logs
</span></span><span class="line"><span class="cl">  ✓ Create s3_bucket.my-app-backup
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Apply complete! <span class="m">2</span> changes applied.
</span></span></code></pre><hr />
<h2>アーキテクチャ</h2>
<pre><code>DSL (.crn) → Parser → Resources → Differ → Plan (Effects) → Interpreter → Provider → Infrastructure
</code></pre>
<ul>
<li><strong>Parser</strong>: pestを使ってDSLをパース</li>
<li><strong>Differ</strong>: 現在の状態と望む状態を比較してEffectを生成</li>
<li><strong>Plan</strong>: Effectのコレクション</li>
<li><strong>Interpreter</strong>: PlanをProviderに渡して実行</li>
<li><strong>Provider</strong>: 実際のインフラ操作を行うトレイト</li>
</ul>
<p>Effectは<code>Create</code>、<code>Update</code>、<code>Delete</code>、<code>Read</code>の4種類があり、それぞれが値として扱われる。</p>
<hr />
<h2>今後</h2>
<p>現状、AWSのS3バケットのみ対応している。今後、Terraformこうなっているといいのにな、と思っていることが実際に実現できるのか、を実験する場にしていこうと考えている。</p>
<p>リポジトリはこちら。</p>
<p><a href="https://github.com/mizzy/carina">mizzy/carina: A functional infrastructure management tool</a></p>

]]></content>
    </entry>

</feed>
