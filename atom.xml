<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Gosuke Miyashita]]></title>
  <link href="http://mizzy.org/atom.xml" rel="self"/>
  <link href="http://mizzy.org/"/>
  <updated>2013-03-27T22:36:46+09:00</updated>
  <id>http://mizzy.org/</id>
  <author>
    <name><![CDATA[Gosuke Miyashita]]></name>
    
  </author>
  <generator uri="https://github.com/mizzy/stellar/">Stellar</generator>


  <entry>
    <title type="html"><![CDATA[Continuous Integration of Puppet with Ukigumo and serverspec]]></title>
    <link href="http://mizzy.org/blog/2013/03/27/2/" />
    <updated>2013-03-27T22:36:46+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/27/2/</id>
    <content type="html"><![CDATA[
<p>I made Puppet CI enviroment with <a href="http://ukigumo.github.com/ukigumo/">Ukigumo</a> . I realize following things.</p>

<ul>
<li>Manage Puppet manifests by Git repository</li>
<li>Set up <a href="http://ukigumo.github.com/Ukigumo-Server/">Ukigumo Server</a> </li>
<li>Make LXC system containers with <a href="/blog/2013/03/24/1">puppet-lxc-test-box</a></li>
<li>Run <a href="https://gist.github.com/mizzy/5252543">my own Ukigumo Client script</a> periodically by cron

<ul>
<li>If master branch of Puppet manifests repository is updated, pull manifests, apply them to LXC system containers and post results to Ukigumo Server.</li>
<li>Run <a href="/blog/2013/03/24/4">serverspec</a> tests to LXC system containers and post results to Ukigumo Server.</li>
</ul></li>
</ul>

<p>This is Ukigumo Server&#39;s top page. Latest results are listed up.</p>

<p><img src="/images/2013/03/ukigumo-top.jpg"></p>

<p>This is the detail of the result of applying Puppet manifests.</p>

<p><img src="/images/2013/03/ukigumo-puppet.jpg"></p>

<p>This is the detail of the results of serverspec tests.</p>

<p><img src="/images/2013/03/ukigumo-serverspec.jpg"></p>

<p>Alaso results are posted to IRC through <a href="http://search.cpan.org/%7Eyappo/App-Ikachan-0.11/lib/App/Ikachan.pm">Ikachan</a>.</p>

<p><img src="/images/2013/03/ukigumo-irc.jpg"></p>

<p>I will refactor Puppet manifests upon this CI environment.</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Ukigumo と serverspec で Puppet の継続的インテグレーション]]></title>
    <link href="http://mizzy.org/blog/2013/03/27/1/" />
    <updated>2013-03-27T21:38:39+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/27/1/</id>
    <content type="html"><![CDATA[
<p><a href="http://blog.64p.org/">tokuhirom</a> さんにより開発されている <a href="http://ukigumo.github.com/ukigumo/">Ukigumo</a> を利用して、Puppet の CI 環境を構築してみた。やってることは以下の通り。</p>

<ul>
<li>Puppet マニフェストを Git リポジトリで管理</li>
<li><a href="http://ukigumo.github.com/Ukigumo-Server/">Ukigumo Server</a> を立てる</li>
<li><a href="/blog/2013/03/22/1/">puppet-lxc-test-box</a> で Puppet マニフェストを流し込むシステムコンテナを必要なロールの分だけ用意</li>
<li><a href="https://gist.github.com/mizzy/5252543">自前の Ukigumo クライアントスクリプト</a> を cron で定期的に走らせ以下を実行

<ul>
<li>Puppet マニフェストリポジトリの master ブランチが更新されていたら、git pull して Puppet マニフェストをシステムコンテナに適用し、適用結果を Ukigumo サーバに投げる</li>
<li><a href="/blog/2013/03/24/3/">serverspec</a> によるテストをシステムコンテナに対して実行し、結果を Ukigumo サーバに投げる</li>
</ul></li>
</ul>

<p>Ukigumo のトップ画面はこんな感じ。最新の結果一覧が表示されている。</p>

<p><img src="/images/2013/03/ukigumo-top.jpg"></p>

<p>Puppet マニフェストの適用結果の詳細はこんな感じ。</p>

<p><img src="/images/2013/03/ukigumo-puppet.jpg"></p>

<p>serverspec によるテスト結果の詳細はこんな感じ。</p>

<p><img src="/images/2013/03/ukigumo-serverspec.jpg"></p>

<p>結果は <a href="http://blog.yappo.jp/yappo/archives/000760.html">Ikachan</a> に投げて IRC で通知してる。</p>

<p><img src="/images/2013/03/ukigumo-irc.jpg"></p>

<p>これで Puppet マニフェストをガリガリとリファクタリングするための準備が整った。</p>

<p><a href="/blog/2013/03/22/1/">puppet-lxc-test-box</a> や <a href="/blog/2013/03/24/3/">serverspec</a> をつくったのは、こういうことがやりたかったから、ってなことを社内 IRC に書いたら、<a href="https://twitter.com/search/realtime?q=%233%E5%88%86%E3%81%A7%E5%B8%B8%E6%9D%BE&amp;src=typd">#3分で常松</a> くんを濡らすことに成功した。</p>

<blockquote class="twitter-tweet"><p>「15:00 mizzy: 最近ブログに書いてたことは、すべてこれへの布石」のカッコイイ感はんぱなくて濡れる</p>&mdash; TSUNEMATSU Shinya (@tnmt) <a href="https://twitter.com/tnmt/status/316792813712977920">March 27, 2013</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Ukigumo もとてもシンプルでいいですね。</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[serverspec が Debian 対応した（してもらった）]]></title>
    <link href="http://mizzy.org/blog/2013/03/25/1/" />
    <updated>2013-03-25T01:52:46+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/25/1/</id>
    <content type="html"><![CDATA[
<p><a href="/blog/2013/03/24/3/">構築済みサーバを RSpec でテストする serverspec という gem をつくった</a> で、「Red Hat 系 Linux 前提のつくりになってしまっているので、他のディストリビューションや OS で利用したい、という方は、ぜひプルリクエストください」と書いていたら、早速 <a href="https://github.com/mizzy/serverspec/pull/1">Debian 系 OS 対応のプルリクエスト</a> をいただきました。ありがとうございます！</p>

<p>単に Debian 系 OS に対応するだけではなく、他の OS にも対応できるよう拡張しやすい形に書き換えていただいたり、serverspec 自体の spec も追加していただいたりと、至れり尽くせりで感謝感謝です。</p>

<pre><code class="ruby">c.include(Serverspec::DebianHelper, :os =&gt; :debian)
</code></pre>

<p>みたいな書き方も知らなかったので、大変参考になりました。</p>

<p><a href="https://github.com/mizzy/serverspec/blob/master/README.md">README</a> にも書いてありますが、こんな感じで OS を指定します。</p>

<pre><code class="ruby">require &#39;spec_helper&#39;

describe &#39;httpd&#39;, :os =&gt; :debian do
  it { should be_installed }
  it { should be_enabled   }
  it { should be_running   }
end

describe &#39;port 80&#39;, :os =&gt; :debian do
  it { should be_listening }
end

describe &#39;/etc/httpd/conf/httpd.conf&#39;, :os =&gt; :debian do
  it { should be_file }
  it { should contain &quot;ServerName www.example.jp&quot; }
end
</code></pre>

<p><code>:os =&gt; :debian</code> と何度も書くのが面倒なら、</p>

<pre><code class="ruby">require &#39;spec_helper&#39;

describe &#39;www.example.jp&#39;, :os =&gt; :debian do
  it do
    &#39;httpd&#39;.should be_installed
  end
  it do
    &#39;httpd&#39;.should be_enabled
  end
  it do
    &#39;httpd&#39;.should be_running
  end

  it do
    &#39;port 80&#39;.should be_listening
  end

  conf = &#39;/etc/httpd/conf/httpd.conf&#39;
  it do
    conf.should be_file
  end
  it do
    conf.should contain &quot;ServerName www.example.jp&quot;
  end
end
</code></pre>

<p>とか書いてもいいですし、</p>

<p><code>serverspec-init</code> で生成される spec/spec_helper.rb に</p>

<pre><code class="ruby">require &#39;serverspec&#39;
require &#39;pathname&#39;

RSpec.configure do |c|
  c.include(Serverspec::DebianHelper)
  c.before do
    c.host = File.basename(Pathname.new(example.metadata[:location]).dirname)
  end
end
</code></pre>

<p>な感じで <code>c.include(Serverspec::DebianHelper)</code> を追加して、</p>

<pre><code class="ruby">require &#39;spec_helper&#39;

describe &#39;httpd&#39; do
  it { should be_installed }
  it { should be_enabled   }
  it { should be_running   }
end

describe &#39;port 80&#39; do
  it { should be_listening }
end

describe &#39;/etc/httpd/conf/httpd.conf&#39; do
  it { should be_file }
  it { should contain &quot;ServerName www.example.jp&quot; }
end
</code></pre>

<p>といった感じで、spec 内では OS は指定しない、といった書き方もできます。</p>

<p>好きなスタイルを選んでください。</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[serverspec - a rubygem for testing provisioned servers with RSpec]]></title>
    <link href="http://mizzy.org/blog/2013/03/24/4/" />
    <updated>2013-03-24T18:55:10+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/24/4/</id>
    <content type="html"><![CDATA[
<p>In <a href="/blog/2013/03/24/2/">Testing servers provisioned by Puppet or Chef with RSpec</a>, I wrote how to test provisioned servers with RSpec.</p>

<p>I&#39;ve created a rubygem <a href="https://rubygems.org/gems/serverspec">serverspec</a> for that purpose.</p>

<p><a href="https://github.com/mizzy/serverspec">mizzy/serverspec</a></p>

<p>You can install serverspec with gem install.</p>

<pre><code>$ gem install serverspec
</code></pre>

<p>serverspec-init command creates template files and directories.</p>

<pre><code>$ serverspec-init
 + spec/
 + spec/www.example.jp/
 + spec/www.example.jp/httpd_spec.rb
 + spec/spec_helper.rb
 + Rakefile
</code></pre>

<p>spec/<a href="http://www.example.jp/httpd_spec.rb">www.example.jp/httpd_spec.rb</a> contains example spec code.</p>

<pre><code>require &#39;spec_helper&#39;

describe &#39;httpd&#39; do
  it { should be_installed }
  it { should be_enabled   }
  it { should be_running   }
end

describe &#39;port 80&#39; do
  it { should be_listening }
end

describe &#39;/etc/httpd/conf/httpd.conf&#39; do
  it { should be_file }
  it { should contain &quot;ServerName www.example.jp&quot; }
end
</code></pre>

<p>You can write test code like this.</p>

<p>You may need some settings in ~/.ssh/config and ssh-agent for logging into the target server without the password/passphrase.</p>

<pre><code>Host *.example.jp
   User root
   IdentityFile ~/.ssh/for_serverspec_rsa
</code></pre>

<p>Run tests with rake spec.</p>

<pre><code>$ rake spec
/usr/bin/ruby -S rspec spec/www.example.jp/httpd_spec.rb
......

Finished in 0.99715 seconds
6 examples, 0 failures
</code></pre>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[構築済みサーバを RSpec でテストする serverspec という gem をつくった]]></title>
    <link href="http://mizzy.org/blog/2013/03/24/3/" />
    <updated>2013-03-24T17:35:20+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/24/3/</id>
    <content type="html"><![CDATA[
<p><a href="/blog/2013/03/23/1/">Puppet や Chef で構築したサーバを RSpec でテストする</a> で書いた仕組みを使いやすくするために <a href="https://github.com/mizzy/serverspec">serverspec</a> という名前で gem 化してみた。</p>

<p>rubygems.org にも登録してあるので、gem install でインストールできる。</p>

<pre><code>$ gem install serverspec
</code></pre>

<p>インストールしたら、適当なディレクトリで serverspec-init を実行。すると、雛形となるディレクトリやファイルを生成する。</p>

<pre><code>$ serverspec-init
 + spec/
 + spec/www.example.jp/
 + spec/www.example.jp/httpd_spec.rb
 + spec/spec_helper.rb
 + Rakefile
</code></pre>

<p>spec/<a href="http://www.example.jp/httpd_spec.rb">www.example.jp/httpd_spec.rb</a> がサンプルテストコードで、こんな感じになってる。</p>

<pre><code>require &#39;spec_helper&#39;

describe &#39;httpd&#39; do
  it { should be_installed }
  it { should be_enabled   }
  it { should be_running   }
end

describe &#39;port 80&#39; do
  it { should be_listening }
end

describe &#39;/etc/httpd/conf/httpd.conf&#39; do
  it { should be_file }
  it { should contain &quot;ServerName www.example.jp&quot; }
end
</code></pre>

<p>これに倣って spec/target.example.jp/xxxxx_spec.rb というファイルをつくって、テストを書いていく。</p>

<p>テスト対象のホストには SSH でアクセスするので、パスワード入力しなくて良いように、~/.ssh/config を書いたり、ssh-agent を利用したりすると良いでしょう。</p>

<pre><code>Host *.example.jp
   User root
   IdentityFile ~/.ssh/for_serverspec_rsa
</code></pre>

<p>rake spec でテストを実行。</p>

<pre><code>$ rake spec
/usr/bin/ruby -S rspec spec/www.example.jp/httpd_spec.rb
......

Finished in 0.99715 seconds
6 examples, 0 failures
</code></pre>

<p><strike>Red Hat 系 Linux 前提のつくりになってしまっているので、他のディストリビューションや OS で利用したい、という方は、ぜひプルリクエストください。</strike> → <a href="https://github.com/mizzy/serverspec/pull/1">Debian 系 OS 対応プルリクエスト</a> をいただいたので、マージして対応しました！</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Testing servers provisioned by Puppet or Chef with RSpec]]></title>
    <link href="http://mizzy.org/blog/2013/03/24/2/" />
    <updated>2013-03-24T02:29:42+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/24/2/</id>
    <content type="html"><![CDATA[
<p><strong>Note:</strong> I made <a href="https://github.com/mizzy/serverspec">serverspec</a> gem for this purpose. Please see the entry <a href="/blog/2013/03/24/4/">serverspec - a rubygem for testing provisioned servers with RSpec</a>.</p>

<p><a href="/blog/2013/03/24/1/">I&#39;ve made a Puppet module for creating LXC system containers</a>.Next I&#39;ve tried to the basis for writing test code easily.</p>

<p>With <a href="https://github.com/mizzy/rspec-lxc-test-box">rspec-lxc-test-box</a>, you can write code for testing server status like this.</p>

<pre><code class="ruby">require &#39;container_spec_helper&#39;

describe &#39;nrpe&#39; do
  it { should be_installed }
  it { should be_enabled   }
  it { should be_running   }
end

describe &#39;nagios-plugins-all&#39; do
  it { should be_installed }
end

describe &#39;/etc/nagios/nrpe.cfg&#39; do
  it { should be_file }
  it { should contain &#39;server_port=5666&#39; }
end

describe &#39;/etc/nrpe.d/01base.cfg&#39; do
  it { should be_file }
end

describe &#39;port 5666&#39; do
  it { should be_listening }
end
</code></pre>

<p>This code accesses to a container through SSH and execute commands to check whether files exist, packages are installed, files contain some strings, services run, some ports listen and so on.Very simple.(But code base are specific for Red Hat and its clone OS.)</p>

<p>You can see how I make it simply <a href="https://github.com/mizzy/rspec-lxc-test-box/tree/master/spec/support/matchers">with these codes</a>.</p>

<p>This test code works with any servers provisioned by any tools(Puppet, Chef, CFEngine, Shell Script, Hands and so on).</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Create LXC system containers easily with Puppet]]></title>
    <link href="http://mizzy.org/blog/2013/03/24/1/" />
    <updated>2013-03-24T01:47:23+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/24/1/</id>
    <content type="html"><![CDATA[
<h2>Overview</h2>

<p>I&#39;m refactoring <a href="https://puppetlabs.com/">Puppet</a> manifests and refactoring requires automated testing.</p>

<p><a href="http://rspec-puppet.com/">rspec-puppet</a> and <a href="http://projects.puppetlabs.com/projects/cucumber-puppet/wiki">cucumber-puppet</a> test Puppet catalog, but I need to test actual server status that Puppet manifests applied to.</p>

<p>For actual testing, several virtual machines are needed. <a href="http://www.vagrantup.com/">Vagrant</a> is the one for creating virtual machines for testing easily.</p>

<p>But I&#39;m using <a href="http://www.linux-kvm.org/page/Main_Page">KVM</a> mainly and would like to create virtual machines for testing on a KVM based virtual machine.</p>

<p><a href="http://lxc.sourceforge.net/">LXC</a> suits that purpose.</p>

<p>For testing purpose, how to create LXC system containers easily is important. So I&#39;ve created a Puppet module to create LXC system containers easily.</p>

<p><a href="https://github.com/mizzy/puppet-lxc-test-box">mizzy/puppet-lxc-test-box</a></p>

<hr>

<h2>How To Use</h2>

<p>First, git clone puppet-lxc-test-box module and puppet-sysctl module.</p>

<pre><code>$ git clone git://github.com/mizzy/puppet-lxc-test-box.git lxc-test-box
$ git clone git://github.com/duritong/puppet-sysctl.git sysctl
</code></pre>

<p>Next, write a manifest to create system containers.</p>

<pre><code>include lxc-test-box

Exec { path =&gt; &#39;/sbin:/usr/sbin:/bin:/usr/bin&#39; }

lxc-test-box::lxc::setup { &#39;proxy&#39;: ipaddress =&gt; &#39;172.16.0.2&#39; }
lxc-tets-box::lxc::setup { &#39;www&#39;:   ipaddress =&gt; &#39;172.16.0.3&#39; }
lxc-test-box::lxc::setup { &#39;db&#39;:    ipaddress =&gt; &#39;172.16.0.4&#39; }
</code></pre>

<p>Apply this manifest.</p>

<pre><code>$ sudo puppet apply --modulepath=. lxc-test-box.pp
</code></pre>

<p>3 containers will be created.</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Puppet や Chef で構築したサーバを RSpec でテストする]]></title>
    <link href="http://mizzy.org/blog/2013/03/23/1/" />
    <updated>2013-03-23T22:34:15+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/23/1/</id>
    <content type="html"><![CDATA[
<p><strong>追記</strong> ここに書いてあることを実現する <a href="https://github.com/mizzy/serverspec">serverspec</a> という gem をつくりました。詳しくは<a href="/blog/2013/03/24/3/">こちらのエントリ</a>で。</p>

<p>Puppet マニフェストをリファクタリングするからテスト書くぞ、ってことで、 <a href="/blog/2013/03/22/1/">puppet-lxc-test-box</a> に書いたように、テストするためのシステムコンテナを簡単に作る仕組みをつくったので、今度は実際にテストコードを書くためのベースをつくってみた。</p>

<p><a href="https://github.com/mizzy/rspec-lxc-test-box">rspec-lxc-test-box</a></p>

<p>こんな感じでテストが書ける。</p>

<pre><code class="ruby">require &#39;container_spec_helper&#39;

describe &#39;nrpe&#39; do
  it { should be_installed }
  it { should be_enabled   }
  it { should be_running   }
end

describe &#39;nagios-plugins-all&#39; do
  it { should be_installed }
end

describe &#39;/etc/nagios/nrpe.cfg&#39; do
  it { should be_file }
  it { should contain &#39;server_port=5666&#39; }
end

describe &#39;/etc/nrpe.d/01base.cfg&#39; do
  it { should be_file }
end

describe &#39;port 5666&#39; do
  it { should be_listening }
end
</code></pre>

<p>やってることはすごく単純で、システムコンテナに対して SSH でアクセスしてコマンドを叩いて、パッケージがインストールされているか、とか、ファイルが存在するか、とか、ファイルに特定の文字列が含まれてるか、とか、サービスが動いているか、とか、特定のポートで Listen してるか、とかを確認してる。（ただし、Red Hat 系 OS を対象としてるので、他の OS ではそのままでは動かない部分もある。）</p>

<p>具体的にどんなことをやってるかは、<a href="https://github.com/mizzy/rspec-lxc-test-box/tree/master/spec/support/matchers">この辺</a> を見てもらえば、すごく単純だということがわかると思う。</p>

<p>実際にコンテナに SSH でアクセスしてテストするので、別に LXC じゃなくても、KVM でも VirtualBox でも VMWare でも物理マシンでも OK だし、Puppet だろうが Chef だろうが CFEngine だろうがシェルスクリプトだろうが手動での構築だろうが、どんな構築手段でも利用できる。</p>

<p><a href="https://github.com/opscode/test-kitchen">Test Kitchen</a> で同じようなことできるんだから、おとなしく Puppet と LXC じゃなくて Chef と Vagrant 使えばいいじゃん、って思われるかもしれないけど、Test Kitchen はなんか大げさすぎて肌に合わない。見通しがいい小さなツールを組み合わせるのが好きなので、<a href="/blog/2013/03/22/1/">puppet-lxc-test-box</a> とかこれとか作ってる。</p>

<p>これと同じようなことは、実は <a href="https://twitter.com/hiboma">@hiboma</a> が既に Sqale で Chef と組み合わせてやっていて、色々参考にさせてもらった。Chef Casual Talk とかがあれば、たぶんこの辺の話をしてくれるんじゃないかな。</p>

<p>こういったテスト駆動サーバ構築的なアプローチは、実は <a href="http://shibuya.pm.org/blosxom/techtalks/200702.html">デブサミ2007出張Shibuyaイベント</a> や <a href="http://tokyo2007.yapcasia.org/sessions/2007/02/assurer_a_pluggable_server_tes.html">YAPC::Asia 2007 Tokyo</a> で発表した <a href="http://www.slideshare.net/mizzy/assurer-a-pluggable-server-testingmonitoring-framework">Assurer というツール</a> でやろうとしてた。</p>

<p>ただ Assurer は、最初から汎用的にしようと意識しすぎて、プラガブルにしたり、複数の OS にも対応できる仕組みを入れたり、といった感じで、構想がでかすぎて自分の手に負えないものになってしまって、使わなくなってしまった。（余談。ツールとしては失敗だったけど、これきっかけで <a href="https://twitter.com/lamanotrama">@lamanotrama</a> とメールのやりとりがあって、その後ペパボに入社してくれたので、ある意味成功だったと言える。）</p>

<p>これで Puppet マニフェストをリファクタリングするためのベースとなる仕組みはできたので、次は実際にガリガリとテストコードを書いていく予定。</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[puppet-lxc-test-box]]></title>
    <link href="http://mizzy.org/blog/2013/03/22/1/" />
    <updated>2013-03-22T02:19:00+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/22/1/</id>
    <content type="html"><![CDATA[
<p>新たな Puppet のベストプラクティスを求めて、マニフェストの大規模なリファクタリングを行っています。</p>

<p>で、リファクタリングするからにはテストが必要だよね、ってことで、<a href="http://rspec-puppet.com/">rspec-puppet</a> でテストを書いてるんだけど、rspec-puppet はマニフェストがコンパイルされた「カタログ」というものに対してテストするもので、実際にマニフェストを流し込んだ状態が正しいかテストするわけではないので、これだとテストとしては不完全。</p>

<p>というわけで、<a href="https://github.com/opscode/test-kitchen">Test Kitchen</a> みたいに、同時にいくつも VM を立ててテストを走らせる、ってなことをやりたいんだけど、会社では KVM ベースの VM を利用してるので、VirtualBox ベースの Vagrant は使えないし、そもそもテストを動かす大元のホストも VM なので、VirtualBox どころか KVM も利用できない。</p>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>なので、まずは LXC のシステムコンテナをさくさくと作るための Puppet モジュールを書いてみた。</p>

<p><a href="https://github.com/mizzy/puppet-lxc-test-box">puppet-lxc-test-box</a></p>

<p>( <a href="https://github.com/fgrehm/vagrant-lxc">vagrant-lxc</a> というのもあるけど、&quot;Vagrant &gt;= 1.1.0, the lxc package and a Kernel higher than 3.5.0-17.28, which on Ubuntu 12.10 means something like&quot; ってなことが書かれていて、メインで使ってる RedHat 系 OS では動く気がしないのでスルー。)</p>

<p>使い方は次のような感じ。まず lxc-test-box モジュールと sysctl モジュールを持ってくる。</p>

<pre><code>$ git clone git://github.com/mizzy/puppet-lxc-test-box.git lxc-test-box
$ git clone git://github.com/duritong/puppet-sysctl.git sysctl
</code></pre>

<p>以下のように、Exec リソースのデフォルト値と、システムコンテナのホスト名と IP アドレスを書いたマニフェスト lxc-test-box.pp を作成。</p>

<pre><code>include lxc-test-box

Exec { path =&gt; &#39;/sbin:/usr/sbin:/bin:/usr/bin&#39; }

lxc-test-box::lxc::setup { &#39;base&#39;:   ipaddress =&gt; &#39;172.16.0.2&#39; }
lxc-test-box::lxc::setup { &#39;manage&#39;: ipaddress =&gt; &#39;172.16.0.3&#39; }
lxc-test-box::lxc::setup { &#39;smtp&#39;:   ipaddress =&gt; &#39;172.16.0.4&#39; }
</code></pre>

<p>マニフェストを流し込む。</p>

<pre><code>$ sudo puppet apply --modulepath=. lxc-test-box.pp
</code></pre>

<p>これで、ホスト OS への lxc パッケージのインストール、ブリッジインターフェース br0 の作成、IP マスカレードの設定を行い、指定されたホスト名と IP アドレスでシステムコンテナを作成し、コンテナの起動までしてくれる。所要時間は、コンテナひとつあたり5分ぐらい。</p>

<p>起動したら、</p>

<pre><code>$ ssh root@base.lxc-test-box
</code></pre>

<p>で、ログインできる。ログイン用の鍵は Puppet で設定済み。（ただし、鍵は /root/.ssh 以下に置いてあるので、必要ならそこからコピーを。）テスト目的なのでホストOSとは通信できるけど、外部からは通信できない。ただし、ホスト OS で IP マスカレードの設定はしてあるので、コンテナから外部への通信は可能。</p>

<p>同梱している lxc パッケージは Scientifix Linux 6.2 + Kernel 2.6.32-358.2.1.el6.x86_64 上でビルドしたものなので、RedHat 6 系以外ではたぶん動かないし、カーネルバージョンが違うと動かないかもしれない。</p>

<p>これでテスト用のシステムコンテナを量産できるようになったので、次は実際にテストする仕組みを作り込む。</p>

<hr>

<p>KVM な VM の上で KVM な VM は動かせない、と思っていたら、<a href="https://twitter.com/ursm">@usrm</a> さんから、最近のカーネルであればネストできるはず、という情報をいただきました。</p>

<blockquote class="twitter-tweet"><p>@<a href="https://twitter.com/gosukenator">gosukenator</a> 最近のカーネルであれば KVM のネストはできるはずです <a href="http://t.co/HZf5HhhUYs" title="http://networkstatic.net/nested-kvm-hypervisor-support/">networkstatic.net/nested-kvm-hyp…</a></p>&mdash; Keita Urashima (@ursm) <a href="https://twitter.com/ursm/status/314802865313042432">March 21, 2013</a></blockquote>

<p>とても有益な情報ありがとうございます！今度試してみよう。</p>

]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[最小手順の Vagrant base box の作り方]]></title>
    <link href="http://mizzy.org/blog/2013/03/11/1/" />
    <updated>2013-03-11T22:28:50+09:00</updated>
    <id>http://mizzy.org/blog/2013/03/11/1/</id>
    <content type="html"><![CDATA[
<p><a href="http://www.vagrantup.com/">Vagrant</a> の base box をつくるためのツールとして <a href="https://github.com/jedi4ever/veewee">VeeWee</a> があって、これはこれで素晴らしいツールなんだけど、VeeWee は裏で ISO イメージをダウンロードしたり、インストーラを走らせたりで、時間もかかるし大げさな感じがするので、もっと簡略化できないか、ってことでやってみた。</p>

<p><a href="/blog/2013/02/24/1/">最小手順のVMイメージの作り方</a> で紹介したシェルスクリプトで作成した VM イメージに対して、以下のようにコマンドを実行するだけで、package.box ができあがる。</p>

<pre><code class="text"># VBoxManage convertfromraw --format vmdk /tmp/sl63.img /tmp/sl63.vmdk
# VBoxManage createvm --name SL6.3-x86_64 --register
# VBoxManage modifyvm SL6.3-x86_64 --memory 512 --acpi on --nic1 nat
# VBoxManage storagectl SL6.3-x86_64 --name &quot;IDE Controller&quot; --add ide
# VBoxManage modifyvm SL6.3-x86_64 --hda /tmp/sl63.vmdk
# vagrant package --base SL6.3-x86_64
</code></pre>

<p>できあがった package.box に対して以下のようにすれば、VM が起動する。</p>

<pre><code class="text">$ vagrant box add sl63-x86_64 package.box
$ vagrant init sl63-x86_64
$ vagrant up
</code></pre>

<p>ただし、<a href="http://docs-v1.vagrantup.com/v1/docs/base_boxes.html">Vagrant Documentation - Documentation - Base Boxes</a> にあるような、vagrant ユーザの作成とか、鍵の設定なんかはしてないため、<code>vagrant ssh</code> ではログインできないので、<code>ssh root@localhost -p 2222</code> で、パスワードは root でログインする。</p>

<p>この辺の設定もシェルスクリプトに組み込んじゃえばいいんだろうけど、まずは base box を簡単に作れるかどうかだけ確かめたかったので、今日はここまで。</p>

]]></content>
  </entry>


</feed>
